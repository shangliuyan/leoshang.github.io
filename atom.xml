<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  
  <title><![CDATA[Leo Shang 的 BLOG]]></title>
  <subtitle><![CDATA[随笔]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://yoursite.com//"/>
  <updated>2015-08-09T12:52:13.000Z</updated>
  <id>http://yoursite.com//</id>
  
  <author>
    <name><![CDATA[Leo Shang]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[tornado的网络模型]]></title>
    <link href="http://yoursite.com/2015/07/19/tornado%E7%9A%84%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2015/07/19/tornado的网络模型/</id>
    <published>2015-07-19T10:36:45.000Z</published>
    <updated>2015-08-09T12:52:13.000Z</updated>
    <content type="html"><![CDATA[<p>在网站逐步发展的过程中，很可能就会遇到<a href="http://www.kegel.com/c10k.html" target="_blank" rel="external">C10K</a>问题，python中一个比较流行的解决方式是通过tornado这个web server解决。<br>tornado是一个非阻塞的Web服务器，下面我会结合源码，对tornado进行一下结构来说明。</p>
<h2 id="基础理论">基础理论</h2><p>在这之前，我们需要先弄清楚几个概念，便于我们理解tornado。</p>
<ul>
<li>同步、异步、阻塞和非阻塞这几个概念的区别和联系。这个问题网上内容很多，可以看下<a href="http://www.zhihu.com/question/19732473" target="_blank" rel="external">知乎这个问题的讨论</a>，个人认为还是不错的，几个高票的回答从不同角度说明了问题，看过后应该会有比较清晰的认识。</li>
<li>epoll的原理。这个是tornado的核心，在网上前人说了很多。我推荐这个[知乎讨论]（<a href="http://www.zhihu.com/question/20122137）,@蓝形参和@张亚伟的回答结合看，应该就能理解大概的原理" target="_blank" rel="external">http://www.zhihu.com/question/20122137）,@蓝形参和@张亚伟的回答结合看，应该就能理解大概的原理</a></li>
</ul>
<h2 id="核心模块">核心模块</h2><p>tornado的核心模块分为三部分：</p>
<ul>
<li>httpserver - 服务于 web 模块的一个非常简单的 HTTP 服务器的实现</li>
<li>iostream - 对非阻塞式的 socket 的简单封装，以方便常用读写操作</li>
<li>ioloop - 核心的 I/O 循环</li>
</ul>
<p>我们结合tornado官网的<em>hello world</em>，看看整个过程到底是怎么进行的。<br>hello_world.py:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> tornado.httpserver</span><br><span class="line"><span class="keyword">import</span> tornado.ioloop</span><br><span class="line"><span class="keyword">import</span> tornado.web</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainHandler</span><span class="params">(tornado.web.RequestHandler)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.write(<span class="string">"Hello, world"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    application = tornado.web.Application([</span><br><span class="line">        (<span class="string">r"/"</span>, MainHandler),</span><br><span class="line">    ])</span><br><span class="line">    http_server = tornado.httpserver.HTTPServer(application)</span><br><span class="line">    http_server.listen(<span class="number">8888</span>)                                                                                                                              </span><br><span class="line">    tornado.ioloop.IOLoop.instance().start()</span><br></pre></td></tr></table></figure>
<p>当我们运行python hello_world.py，先实例化一个tornado.web.Application实例<em>application</em>(这个类并不是核心范畴，所以在这里暂且不做说明，可以简单理解为对数据请求进行url路由，并且生成返回数据的一个handler。在hello_world.py中，我们对根目录url的请求，返回“hello world”内容的数据)。</p>
<p>然后将<em>application</em>作为参数，实例化tornado.httpserver.HTTPServer，赋值给http_server，http_server再调用listen方法。<br>这个过程发生了什么，我们来看看httpserver.py。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, request_callback, no_keep_alive=False, io_loop=None,</span><br><span class="line">             xheaders=False, ssl_options=None)</span>:</span></span><br><span class="line">    <span class="string">"""Initializes the server with the given request callback.</span><br><span class="line"></span><br><span class="line">    If you use pre-forking/start() instead of the listen() method to</span><br><span class="line">    start your server, you should not pass an IOLoop instance to this</span><br><span class="line">    constructor. Each pre-forked child process will create its own</span><br><span class="line">    IOLoop instance after the forking process.</span><br><span class="line">    """</span></span><br><span class="line">    self.request_callback = request_callback</span><br><span class="line">    self.no_keep_alive = no_keep_alive</span><br><span class="line">    self.io_loop = io_loop</span><br><span class="line">    self.xheaders = xheaders</span><br><span class="line">    self.ssl_options = ssl_options</span><br><span class="line">    self._socket = <span class="keyword">None</span></span><br><span class="line">    self._started = <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">listen</span><span class="params">(self, port, address=<span class="string">""</span>)</span>:</span></span><br><span class="line">    <span class="string">"""Binds to the given port and starts the server in a single process.</span><br><span class="line"></span><br><span class="line">    This method is a shortcut for:</span><br><span class="line"></span><br><span class="line">        server.bind(port, address)</span><br><span class="line">        server.start(1)</span><br><span class="line"></span><br><span class="line">    """</span></span><br><span class="line">    self.bind(port, address)</span><br><span class="line">    self.start(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>实例化方法除了将<em>application</em>赋值为request_callback外，都是使用的默认值，注意这里<em>io_loop=None</em>。listen方法比较简单，绑定socket然后调用start方法。start方法代码比较多，只看主要逻辑。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> self.io_loop:</span><br><span class="line">    self.io_loop = ioloop.IOLoop.instance()</span><br><span class="line">self.io_loop.add_handler(self._socket.fileno(),</span><br><span class="line">                         self._handle_events,</span><br><span class="line">                         ioloop.IOLoop.READ)</span><br></pre></td></tr></table></figure>
<p>终于出现io_loop，在实例化httpserver的时候io_loop=None，这里将ioloop.IOLoop.instance()赋值给ioloop。值得一提的是ioloop采用单实例模式，所以ioloop.IOLoop.instance()就是返回ioloop的实例。现在跳转到ioloop.py。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_handler</span><span class="params">(self, fd, handler, events)</span>:</span></span><br><span class="line">    <span class="string">"""Registers the given handler to receive the given events for fd."""</span></span><br><span class="line">    self._handlers[fd] = handler</span><br><span class="line">    self._impl.register(fd, events | self.ERROR)</span><br></pre></td></tr></table></figure>
<p>可以看到add_handler方法将fd文件描述符和events事件注册到_impl上，这个_impl可以认为是epoll类（根据操作系统不同可能为kqueue），另外将handler赋值给self._handlers[fd]，_handlers[fd]相当于文件描述符和回调函数对应的字典，当事件触发的时候会调用。回到httpserver.py，我们调用的是</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">self.io_loop.add_handler(self._socket.fileno(),</span><br><span class="line">                         self._handle_events,</span><br><span class="line">                         ioloop.IOLoop.READ)</span><br></pre></td></tr></table></figure>
<p>文件描述符是监听端口的socket，事件READ可以认为I/O是数据读取就绪，回调函数为self._handle_events:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_handle_events</span><span class="params">(self, fd, events)</span>:</span>                                                                                                                     </span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            connection, address = self._socket.accept()</span><br><span class="line">        <span class="keyword">except</span> socket.error, e:</span><br><span class="line">            <span class="keyword">if</span> e[<span class="number">0</span>] <span class="keyword">in</span> (errno.EWOULDBLOCK, errno.EAGAIN):</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">raise</span></span><br><span class="line">        <span class="keyword">if</span> self.ssl_options <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">assert</span> ssl, <span class="string">"Python 2.6+ and OpenSSL required for SSL"</span></span><br><span class="line">            connection = ssl.wrap_socket(</span><br><span class="line">                connection, server_side=<span class="keyword">True</span>, **self.ssl_options)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            stream = iostream.IOStream(connection, io_loop=self.io_loop)</span><br><span class="line">            HTTPConnection(stream, address, self.request_callback,</span><br><span class="line">                           self.no_keep_alive, self.xheaders)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            logging.error(<span class="string">"Error in connection callback"</span>, exc_info=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure>
<p>现在我们可以梳理一下整个过程，httpserver监听一个端口，并把这个文件描述符通过ioloop注册到epoll，只要收到请求，epoll回调_handle_events方法。这个方法做了什么呢？<br>根据请求数据，创建了一个socket连接<em>connection</em>，然后将这个connection作为文件描述符实例化另一个核心模块<em>iostream</em>，赋值为steam，然后使用steam和self.request_callback(tornado.web.Application实例的<em>application</em>)作为主要参数，实例HTTPConnection。<br>HTTPConnection负责HTTP协议部分，它的I/O使用iostream，通过iostream read方法读取数据解析数据包，然后调用application生成返回数据，在调用iostream write方法将数据返回。这个过程的I/O事件注册就靠iostream.<br>我们看下实例iostream的代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, socket, io_loop=None, max_buffer_size=<span class="number">104857600</span>,</span><br><span class="line">             read_chunk_size=<span class="number">4096</span>)</span>:</span></span><br><span class="line">    self.socket = socket</span><br><span class="line">    self.socket.setblocking(<span class="keyword">False</span>)</span><br><span class="line">    self.io_loop = io_loop <span class="keyword">or</span> ioloop.IOLoop.instance()</span><br><span class="line">    self.max_buffer_size = max_buffer_size</span><br><span class="line">    self.read_chunk_size = read_chunk_size</span><br><span class="line">    self._read_buffer = <span class="string">""</span></span><br><span class="line">    self._write_buffer = <span class="string">""</span></span><br><span class="line">    self._read_delimiter = <span class="keyword">None</span></span><br><span class="line">    self._read_bytes = <span class="keyword">None</span></span><br><span class="line">    self._read_callback = <span class="keyword">None</span></span><br><span class="line">    self._write_callback = <span class="keyword">None</span></span><br><span class="line">    self._close_callback = <span class="keyword">None</span></span><br><span class="line">    self._state = self.io_loop.ERROR                                                                                                                      </span><br><span class="line">    self.io_loop.add_handler(</span><br><span class="line">        self.socket.fileno(), self._handle_events, self._state)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_until</span><span class="params">(self, delimiter, callback)</span>:</span></span><br><span class="line">    <span class="string">"""Call callback when we read the given delimiter."""</span></span><br><span class="line">    <span class="keyword">assert</span> <span class="keyword">not</span> self._read_callback, <span class="string">"Already reading"</span></span><br><span class="line">    loc = self._read_buffer.find(delimiter)</span><br><span class="line">    <span class="keyword">if</span> loc != -<span class="number">1</span>:</span><br><span class="line">        self._run_callback(callback, self._consume(loc + len(delimiter)))</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    self._check_closed()</span><br><span class="line">    self._read_delimiter = delimiter</span><br><span class="line">    self._read_callback = callback</span><br><span class="line">    self._add_io_state(self.io_loop.READ)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write</span><span class="params">(self, data, callback=None)</span>:</span></span><br><span class="line">    <span class="string">"""Write the given data to this stream.</span><br><span class="line">    """</span></span><br><span class="line">    self._check_closed()</span><br><span class="line">    self._write_buffer += data</span><br><span class="line">    self._add_io_state(self.io_loop.WRITE)</span><br><span class="line">    self._write_callback = callback</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_add_io_state</span><span class="params">(self, state)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> self._state &amp; state:</span><br><span class="line">        self._state = self._state | state</span><br><span class="line">        self.io_loop.update_handler(self.socket.fileno(), self._state)</span><br></pre></td></tr></table></figure>
<p>可以看到在实例iostream的时候，我们就将返回给客户端的文件描述符注册到ioloop上，但是事件是ERROR。在write和read_until方法中，都调用了_add_io_state方法，这个方法负责更新对应文件描述符的注册事件。</p>
<p>现在我们来看看tornado所谓的单线程主要的任务调度逻辑，ioloop中start方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">start</span><span class="params">(self)</span>:</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    ...</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            event_pairs = self._impl.poll(poll_timeout)</span><br><span class="line">        <span class="keyword">except</span> Exception, e:</span><br><span class="line">            <span class="comment"># Depending on python version and IOLoop implementation,</span></span><br><span class="line">            <span class="comment"># different exception types may be thrown and there are</span></span><br><span class="line">            <span class="comment"># two ways EINTR might be signaled:</span></span><br><span class="line">            <span class="comment"># * e.errno == errno.EINTR</span></span><br><span class="line">            <span class="comment"># * e.args is like (errno.EINTR, 'Interrupted system call')</span></span><br><span class="line">            <span class="keyword">if</span> (getattr(e, <span class="string">'errno'</span>) == errno.EINTR <span class="keyword">or</span></span><br><span class="line">                (isinstance(getattr(e, <span class="string">'args'</span>), tuple) <span class="keyword">and</span></span><br><span class="line">                 len(e.args) == <span class="number">2</span> <span class="keyword">and</span> e.args[<span class="number">0</span>] == errno.EINTR)):</span><br><span class="line">                logging.warning(<span class="string">"Interrupted system call"</span>, exc_info=<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">raise</span></span><br><span class="line">    ...</span><br><span class="line">        self._events.update(event_pairs)</span><br><span class="line">        <span class="keyword">while</span> self._events:</span><br><span class="line">            fd, events = self._events.popitem()</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                self._handlers[fd](fd, events)</span><br><span class="line">            <span class="keyword">except</span> (KeyboardInterrupt, SystemExit):</span><br><span class="line">                <span class="keyword">raise</span></span><br><span class="line">            <span class="keyword">except</span> (OSError, IOError), e:</span><br><span class="line">                <span class="keyword">if</span> e[<span class="number">0</span>] == errno.EPIPE:</span><br><span class="line">                    <span class="comment"># Happens when the client closes the connection</span></span><br><span class="line">                    <span class="keyword">pass</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    logging.error(<span class="string">"Exception in I/O handler for fd %d"</span>,</span><br><span class="line">                                  fd, exc_info=<span class="keyword">True</span>)</span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                logging.error(<span class="string">"Exception in I/O handler for fd %d"</span>,</span><br><span class="line">                              fd, exc_info=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure>
<p>在这里 <code>event_pairs = self._impl.poll(poll_timeout)</code>，陷入epoll，然后<code>while self._events</code>之后的代码，运行触发事件后回调函数。<br>现在我们通过一张图看看整个流程：<br><img src="/img/tornado-httpserver.png" alt="tornado-httpserver图"></p>
<h2 id="还有什么">还有什么</h2><p>我们看到在tornado中，无论运行什么库，只要涉及I/O，都要注册到ioloop上，这样才能发挥异步I/O的作用，否则tornado也回阻塞。所以tornado会有很多第三方库，所以在实际使用中，我们有必要学习一下第三方库的使用。个人以为如果用了celery，这些都库都可以不用了，通过tornado把任务抛到celery，可以省去学习第三方库的成本。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在网站逐步发展的过程中，很可能就会遇到<a href="http://www.kegel.com/c10k.html" target="_blank" rel="external">C10K</a>问题，python中一个比较流行的解决方式是通过tornado这个web s]]>
    </summary>
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="tornado" scheme="http://yoursite.com/tags/tornado/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[python的协程]]></title>
    <link href="http://yoursite.com/2015/07/06/python%E7%9A%84%E5%8D%8F%E7%A8%8B/"/>
    <id>http://yoursite.com/2015/07/06/python的协程/</id>
    <published>2015-07-06T07:18:35.000Z</published>
    <updated>2015-08-09T12:49:28.000Z</updated>
    <content type="html"><![CDATA[<p>关于python的协程，网上资料还是挺多的，这里说一下我的理解吧。</p>
<h2 id="什么是协程？">什么是协程？</h2><p>先看一下wiki的定义吧</p>
<blockquote>
<p>Coroutines are computer program components that generalize subroutines for nonpreemptive multitasking, by allowing multiple entry points for suspending and resuming execution at certain locations.</p>
</blockquote>
<p>这个定义不太容易理解。一句话可能很难直观的说明协程这个概念，通俗讲，协程是由一系列的子程序协同完成一个任务，这些子程序可以主动挂起交出控制权，当恢复执行的时候，可以从挂起的位置继续执行，而这一切的调度由用户操作，而不是操作系统。所以有人称，<em>协程是用户态线程</em>。<br>协程的实现并不与操作系统相关，是语言相关的，所以可以看到主流的一些语言都有协程的实现，包括java，go等。在python中，协程是通过生成器实现的，<em>yeild</em>就可以保存当前子程序上下文，并交出控制权，使用send就可以传递数据并恢复相应子程序。这样多个生成器子程序，就可以通过yield和send相互协作完成任务。</p>
<h2 id="python的协程和生成器的关系">python的协程和生成器的关系</h2><p>说到这里，可能会产生疑问，使用<em>yield</em>的函数不是生成器么？生成器就是协程么？确实如此，参见<a href="https://www.python.org/dev/peps/pep-0342/" target="_blank" rel="external">PEP 342</a>，在python 2.5以前生成器就是仅仅是迭代器函数，可以生成无限列表。但是yield保存上下文，主动交出控制权的特性已经很接近协程了，所以在python 2.5对生成器进行了几个改进：</p>
<ul>
<li>yield从语句变为表达式, 这个是为了传值方便</li>
<li>加入send()方法用于在恢复生成器的时候，传入值</li>
<li>加入close()方法用于结束协程</li>
<li>加入throw()方法用于传入异常<br>加入了send()和throw()方法，我们就可以在协程恢复的时候，传入值或者异常。有了这些特性，python从语言上就支持基本的协程功能了，当然对不同协程的控制，还要用户自己来编写。所以我们可以说，从python 2.5以后的生成器才可以用于作为协程。</li>
</ul>
<h2 id="与greenlet，gevent的关系">与greenlet，gevent的关系</h2><p>介绍完python在语义上对协程的支持，但实际使用中会发现，很少有用生成器方式的协程，一般用greenlets，gevent这样的package代替。为什么会这样呢？主要还是因为python2.x对协程的支持有限，要支持复杂的应用比较困难，但是在python3以后，协程会更加好用，我们看看python对协程的支持历程：</p>
<blockquote>
<p>Implementations for Python</p>
<ul>
<li>Python 2.5 implements better support for coroutine-like functionality, based on extended generators (PEP 342)</li>
<li>Python 3.3 improves this ability, by supporting delegating to a subgenerator (PEP 380)</li>
<li>Python 3.4 introduces a comprehensive asynchronous I/O framework as standardized in PEP 3156, which includes coroutines that leverage subgenerator delegation</li>
<li>Python 3.5 introduces explicit support for coroutines with async/await syntax (PEP 0492).</li>
</ul>
</blockquote>
<p>到Python 3.5都已经有明确的异步操作方法了，但是这些都是2.x所不具备的。所以在python2.x时代，就需要其他实现方式作为补充。<br>greenlet就是这样一个库，它是从stackless python中剥离，支持CPython的版本的一个协程模块, 相当于python协程的增强版。在github上有使用greenlet重新实现生成器的<a href="https://github.com/python-greenlet/greenlet/blob/master/tests/test_generator.py" target="_blank" rel="external">demo</a>，大家可以体会一下greenlet的特性。但是和python 生成器协程一样，greenlet也没有控制调度的功能，如果要实现一个非阻塞的操作，还要自己实现控制调度逻辑，这就催生了gevent的产生。</p>
<blockquote>
<p>gevent is a coroutine-based Python networking library that uses greenlet to provide a high-level synchronous API on top of the libev event loop.<br>Features include:</p>
<ul>
<li>Fast event loop based on libev (epoll on Linux, kqueue on FreeBSD).</li>
<li>Lightweight execution units based on greenlet.</li>
<li>API that re-uses concepts from the Python standard library (for example there are Events and Queues).</li>
<li>Cooperative sockets with SSL support »</li>
<li>DNS queries performed through threadpool or c-ares.</li>
<li>Monkey patching utility to get 3rd party modules to become cooperative »</li>
</ul>
</blockquote>
<p>gevent在greenlet基础上结合libev作为事件循环，补充了协程要自己写异步调度的空缺，最大化了协程的性能。在此基础上，还提供了多种API，方便开发，甚至直接提供了一个支持协程WSGI server，bottle就支持了这个特性。另外值得一提的是它的<em>Monkey patch</em>，可以无缝将python标准库中阻塞的API包装成非阻塞的，这一特性大大提高了gevent的应用率。</p>
<h2 id="协程带来的改变">协程带来的改变</h2><p>面向对象是和现实世界构成的形式一致的，但是不同对象之间的交互，还是采用调用的关系。调用关系隐含的的是主从关系，但现实世界，很多关系的协作是对等的，比如生产者和消费者。协程就是在计算机程序设计中对这种现实反映的实现。<br>下面我们结合程序简要说明协程的几种应用：</p>
<ul>
<li><p>无限列表<br>  假设一种情形，我们需要所有的斐波那契数列，如果不用协程基本上实现不了吧。协程实现就很方便：</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">()</span>:</span></span><br><span class="line">     first, second = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">     <span class="keyword">yield</span> first</span><br><span class="line">     <span class="keyword">yield</span> second</span><br><span class="line">     <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">         third = first + second</span><br><span class="line">         <span class="keyword">yield</span> third</span><br><span class="line">         first = second</span><br><span class="line">         second = third</span><br></pre></td></tr></table></figure>
</li>
<li><p>管道<br>  如果我们想用python实现管道怎么做呢，答案也是协程。下面这个例子来自于<a href="https://books.google.co.jp/books?id=Chr1NDlUcI8C&amp;pg=PA108&amp;lpg=PA108&amp;dq=coroutine+find_files+cat+grep&amp;source=bl&amp;ots=OCDDzmgZCq&amp;sig=6ldU6qqPblKMl0Qv9li3fBmBsyQ&amp;hl=zh-CN&amp;sa=X&amp;ved=0CCIQ6AEwAGoVChMIxL-D1ciWxwIVzQiOCh26tgyg#v=onepage&amp;q=coroutine%20find_files%20cat%20grep&amp;f=false" target="_blank" rel="external">python参考手册</a>，打印指定目录下，满足格式文件中，有“python”关键字的行</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">    <span class="keyword">import</span> os</span><br><span class="line">    <span class="keyword">import</span> fnmatch</span><br><span class="line">    <span class="keyword">import</span> gzip, bz2</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">coroutine</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="string">"""自动调用协程的next()函数"""</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">start</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">            g = func(*args, **kwargs)</span><br><span class="line">            g.next()</span><br><span class="line">            <span class="keyword">return</span> g</span><br><span class="line">        <span class="keyword">return</span> start</span><br><span class="line">    </span><br><span class="line"><span class="decorator">    @coroutine</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_files</span><span class="params">(target)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            topdir, pattern = (<span class="keyword">yield</span>)</span><br><span class="line">            <span class="keyword">for</span> path, dirname, filelist <span class="keyword">in</span> os.walk(topdir):</span><br><span class="line">                <span class="keyword">for</span> name <span class="keyword">in</span> filelist:</span><br><span class="line">                    <span class="keyword">if</span> fnmatch.fnmatch(name, pattern):</span><br><span class="line">                        target.send(os.path.join(path, name))</span><br><span class="line">    </span><br><span class="line"><span class="decorator">    @coroutine</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">opener</span><span class="params">(target)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            name = (<span class="keyword">yield</span>)</span><br><span class="line">            <span class="keyword">if</span> name.endswith(<span class="string">'.gz'</span>): f = gzip.open(name)</span><br><span class="line">            <span class="keyword">elif</span> name.endswith(<span class="string">'.bz2'</span>): f = bz2.BZ2File(name)</span><br><span class="line">            <span class="keyword">else</span>: f = open(name)</span><br><span class="line">            target.send(f)</span><br><span class="line">    </span><br><span class="line"><span class="decorator">    @coroutine</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cat</span><span class="params">(target)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            f = (<span class="keyword">yield</span>)</span><br><span class="line">            <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">                target.send(line)</span><br><span class="line">    </span><br><span class="line"><span class="decorator">    @coroutine</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">grep</span><span class="params">(pattern, target)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            line = (<span class="keyword">yield</span>)</span><br><span class="line">            <span class="keyword">if</span> pattern <span class="keyword">in</span> line:</span><br><span class="line">                target.send(line)</span><br><span class="line"><span class="decorator">    @coroutine</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printer</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            line = (<span class="keyword">yield</span>)</span><br><span class="line">            sys.stdout.write(line)</span><br><span class="line">    </span><br><span class="line">    finder = find_files(opener(cat(grep(<span class="string">'python'</span>, printer))))</span><br><span class="line"></span><br><span class="line">finder.send(<span class="string">'www'</span>, <span class="string">'access-log*'</span>)</span><br><span class="line">finder.send(<span class="string">'otherwww'</span>, <span class="string">'access-log*'</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>并发<br>  关于并发，最好的例子应该是gevent吧，大家有兴趣可以看下源码。基本的原理是，将函数变为协程，每触发I/O阻塞就yield交出控制权，并将事件注册到epoll，当I/O就绪就是用send方法，传入I/O数据，并恢复逻辑。这么描述其实和tornado、nodejs的网络模型很像，但是协程对于程序员更加友好。tornado和nodejs默认还是通过回调函数完成这个事件循环的，这样代码并不直观，但使用协程可以用同步的方式完成回调函数的工作。</p>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>关于python的协程，网上资料还是挺多的，这里说一下我的理解吧。</p>
<h2 id="什么是协程？">什么是协程？</h2><p>先看一下wiki的定义吧</p>
<blockquote>
<p>Coroutines are computer program comp]]>
    </summary>
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[celery有什么难理解的?]]></title>
    <link href="http://yoursite.com/2015/07/04/celery%E6%9C%89%E4%BB%80%E4%B9%88%E9%9A%BE%E7%90%86%E8%A7%A3%E7%9A%84/"/>
    <id>http://yoursite.com/2015/07/04/celery有什么难理解的/</id>
    <published>2015-07-04T06:09:06.000Z</published>
    <updated>2015-08-09T12:53:09.000Z</updated>
    <content type="html"><![CDATA[<p>两年前，公司所有的管理后台用的都是django admin，我们遇到一个复杂的需求，需要从django admin调用执行一个大批量处理脚本，并且可以查看执行状态。<br>当时不太了解celery，加上时间紧迫，就没敢冒险。简单说说我们当时是怎么做的，我们把这个脚本做成了command line的形式，django使用python的subprocess调用这个命令，为了满足可以查看状态这个需求，我们单独创建了一个任务表，在启动脚本时先插入数据，完成或者异常都更新这条数据状态，这样在django admin里就能看到执行状态了。<br>这个方法满足了需求，并沿用到现在，但是这里有一个显而易见的硬伤：django必须和这个脚本在同一个服务器上。好吧，毫无可拓展性。<br>其实这个就是一个天然celery使用场景，如果使用celery就可以轻松解决分布拓展问题。</p>
<h2 id="什么是celery？">什么是celery？</h2><p>说了这么多，什么是celery呢？<a href="http://www.celeryproject.org/" target="_blank" rel="external">官网</a>定义：</p>
<blockquote>
<p>Celery is an asynchronous task queue/job queue based on distributed message passing.</p>
</blockquote>
<p>celery是一个基于分布消息传递的异步任务队列。定义很简单，但是这里隐含了一个条件就是celery不是单独存在的，它一定需要建立在一个分布的消息传递机制上，这个消息传递机制就是celery文档里常说的<em>broker</em>。我认为这是第一个难以理解的点。<br>一般情况下，一个工具库或者一个框架都是独立的，有自己的feature或者功能点，可能依赖其他的库，但绝不依赖于其他服务。但是celery是一个特例，如果celery没有broker这个服务，那就完全不能用了。这就是为什么现在网络上大多数celery文章都是和rabbitmq或者redis一起讲的。<br>清楚这点，知道了broker和celery的关系，就不会有rabbitmq不就可以做任务队列吗？为什么和celery结合？这样的疑问。事实上，在<a href="https://www.rabbitmq.com/tutorials/tutorial-two-python.html" target="_blank" rel="external">官网</a>上就有使用rabbit作为任务队列的实现，多种语言都有。rabbitmq是消息代理中间件，具体应用到什么场景，怎么用，用什么语言，都可以自己定义，celery也实现了这个接口而已。</p>
<h2 id="celery结构框架">celery结构框架</h2><p>下面贴一个celery+rabbitmq的结构图，个人认为挺能说明问题：<br><img src="/img/RabbitMQRouting.png" alt="celery rabbitmq结构图"><br>celery隐藏了rabbitmq接口的实现细节，既充当了publisher（client）又充当了consumer (worker)的角色。<br>这是第二个难理解的点，这个困扰可能来源于celery提供的get start文档，如果按照这个文档一步步走，确实能走通流程。但是这个通俗的demo有一个问题，就是他的publisher和consumer都在一台server上，并且client调用具体任务的方式是通过import。这让人很难理解，为什么说celery是分布的呢？但是奇怪的是，官方demo就没有publisher和consumer分布在两台server的例子。</p>
<p><img src="/img/Producer-Broker-Consumer-Arrangement.png" alt="client broker worker关系图"><br>如上图所示，producer、broker、consumer之间的网络拓扑关系可以有这5种情形。</p>
<h2 id="celery到底做了什么？">celery到底做了什么？</h2><p>上文说了，rabbitmq官网就有demo做任务队列的，那要celery有何用呢？还有上边，我提到的那个需求，没用celery，虽然拓展性不好，但是改一下用一个web服务代替不就行了么？这么说没错，但都是重复造轮子。<br>思考一下，如果我们用rabbitmq自己实现任务队列，有一天我们不想用rabbit了怎么办？我们换个思维，如果没有celery，让你自己设计一个异步任务队列你怎么做。首先，要有一个发起任务的client，选定一定保存任务信息的媒介，由一个worker去一直监听这个信息媒介，这个worker最好是多进程的，另外可以兼容尽可能多得信息媒介。好吧，这个不就是celery所做的事儿么，celery兼容多个broker，既是任务发起者又是执行者，另外支持多进程…还有好多通用功能考虑。<br>看一下这个图体会一下celery+rabbitmq的整个工作流程：</p>
<p><img src="/img/Celery_RabitMQ_Diagram.png" alt="Celery_RabitMQ_Diagram"></p>
<h2 id="我是怎么用的?">我是怎么用的?</h2><p>说了这么多，来看看我是怎么用的。</p>
<ol>
<li><p>选择broker和result backend<br>  知道了原理，这个选择要容易些，对于消息中转，没有比rabbitmq更灵活健壮的了，至于对result backend的存储，仁者见仁。rabbitmq安装配置<a href="http://celery.readthedocs.org/en/latest/getting-started/brokers/rabbitmq.html" target="_blank" rel="external">参考</a></p>
</li>
<li><p>提取celery配置文件<br> 把共有配置文件提出来，进行维护，比分别维护producer和consumer的配置统一容易的多。<br> celeryconfig.py</p>
 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BROKER_URL = <span class="string">'amqp://test01:password@192.10.2.156//'</span></span><br><span class="line">CELERY_RESULT_BACKEND = <span class="string">'amqp://test01:password@192.10.2.156//'</span></span><br><span class="line">CELERY_ACCEPT_CONTENT = [<span class="string">'json'</span>]</span><br><span class="line">CELERY_TASK_SERIALIZER = <span class="string">'json'</span></span><br><span class="line">CELERY_RESULT_SERIALIZER = <span class="string">'json'</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>consumer（server）端开发</p>
<ul>
<li><p>在项目目录下创建app.py文件</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> Celery</span><br><span class="line">app = Celery(<span class="string">'tqlib'</span>, include=[<span class="string">'tq.tasks'</span>])</span><br><span class="line">app.config_from_object(<span class="string">'celeryconfig'</span>)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app.start()</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建tasks.py</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tq.app <span class="keyword">import</span> app</span><br><span class="line"><span class="decorator">@app.task</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(no)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> no</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动多进程服务<br>  项目目录结构为</p>
<pre><code>tq<span class="comment">----app.py</span>
  |<span class="comment">---tasks.py</span>
  |<span class="comment">---celeryconfig.py</span>
</code></pre><p>  启动指令为：</p>
  <figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">celery multi restart ccworker --<span class="keyword">app</span>=tq.<span class="keyword">app</span>  -<span class="keyword">l</span> info</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>producer(client)端开发</p>
 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> Celery</span><br><span class="line">celery = Celery()</span><br><span class="line">celery.config_from_object(<span class="string">'celeryconfig'</span>)</span><br><span class="line">celery.send_task(<span class="string">'tq.tasks.test'</span>, (<span class="string">"hello world"</span>,))</span><br></pre></td></tr></table></figure>
<p>注意，就是celery.send_task()这个方法解决了producer和consumer的网路拓扑传递数据问题。 </p>
</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>两年前，公司所有的管理后台用的都是django admin，我们遇到一个复杂的需求，需要从django admin调用执行一个大批量处理脚本，并且可以查看执行状态。<br>当时不太了解celery，加上时间紧迫，就没敢冒险。简单说说我们当时是怎么做的，我们把这个脚本做成了c]]>
    </summary>
    
      <category term="celery" scheme="http://yoursite.com/tags/celery/"/>
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[sqlalchemy如何分表]]></title>
    <link href="http://yoursite.com/2015/06/29/sqlchemy%E5%A6%82%E4%BD%95%E5%88%86%E8%A1%A8/"/>
    <id>http://yoursite.com/2015/06/29/sqlchemy如何分表/</id>
    <published>2015-06-29T13:45:39.000Z</published>
    <updated>2015-08-09T12:53:16.000Z</updated>
    <content type="html"><![CDATA[<h2 id="背景">背景</h2><p>话说sqlalchemy真是一个非常好用的库，python orm基本上是舍我其谁了，文档还非常全面，基本上没有什么硬伤，现在也冲出了1.0版本，未来更加值得期待。<br>我最早用django orm，不过很快就觉得很多功能不够用，我当时用的版本是1.3.1，没有<em>bulk insert</em>也没有<em>锁</em>，没有这两个功能，好多应用就没法用django开发了。之后开始接触sqlalchemy，一直用到现在，总的体会是只有你想不到没有它做不到。</p>
<p>我们项目里有一个需求，就是数据按月分表，比如:2014年6月数据就存在<em>record_201406</em>表中, 其他月数据按此方法类推。这个需求如果是用sqlalchemy来获取数据，我们怎么做呢？</p>
<h2 id="一般方法有什么问题？">一般方法有什么问题？</h2><p>一般情况下，我们很自然想到使用如下方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RecodeDao_201406</span><span class="params">(Base)</span>:</span></span><br><span class="line">   	__tablename__ = <span class="string">'record_201406'</span></span><br><span class="line">   	id = Column(INT(<span class="number">11</span>), primary_key=<span class="keyword">True</span>)</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure>
<p>或者简化点：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RecodeDao_201406</span><span class="params">(Base)</span>:</span></span><br><span class="line">   	__table__ = Table(<span class="string">'record_201406'</span>,</span><br><span class="line">       Base.metadata, autoload=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure>
<p>这样实现确实没问题，但回到需求上，既然是按月分表，难不成我要每个月写一个这样的model？每月上次线？当然不行，那我们怎么解决呢？</p>
<h2 id="官网解决方法，有什么问题？">官网解决方法，有什么问题？</h2><p>有经验的同学可能发现，这个不就是水平<em>sharding</em>么？这么说不完全对，看一下sharding的<em>wiki</em>定义：</p>
<blockquote>
<p>A database shard is a horizontal partition of data in a database or search engine. Each individual partition is referred to as a shard or database shard. Each shard is held on a separate database server instance, to spread load.</p>
</blockquote>
<p>我们这个需求只涉及单数据库，就不算<em>sharding</em>了，可以称为<em>partitioning</em>（分区），然而强大的sqlalchemy这两个情况都考虑到了，并且官网都提供了<a href="http://docs.sqlalchemy.org/en/rel_1_0/orm/examples.html#examples-sharding" target="_blank" rel="external">example</a>，我们挑对应场景的partitioning出来看看:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> sqlalchemy.orm <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> sqlalchemy.ext.declarative <span class="keyword">import</span> declarative_base</span><br><span class="line"></span><br><span class="line">Base = declarative_base()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TBase</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""Base class is a 'mixin'.</span><br><span class="line"></span><br><span class="line">    Guidelines for declarative mixins is at:</span><br><span class="line"></span><br><span class="line">    http://www.sqlalchemy.org/docs/orm/extensions/declarative.html#mixin-classes</span><br><span class="line"></span><br><span class="line">    """</span></span><br><span class="line">    id = Column(Integer, primary_key=<span class="keyword">True</span>)</span><br><span class="line">    data = Column(String(<span class="number">50</span>))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"%s(data=%r)"</span> % (</span><br><span class="line">            self.__class__.__name__, self.data</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T1Foo</span><span class="params">(TBase, Base)</span>:</span></span><br><span class="line">    __tablename__ = <span class="string">'t1'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T2Foo</span><span class="params">(TBase, Base)</span>:</span></span><br><span class="line">    __tablename__ = <span class="string">'t2'</span></span><br><span class="line"></span><br><span class="line">    timestamp = Column(DateTime, default=func.now())</span><br><span class="line"></span><br><span class="line">engine = create_engine(<span class="string">'sqlite://'</span>, echo=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line">Base.metadata.create_all(engine)</span><br><span class="line"></span><br><span class="line">sess = sessionmaker(engine)()</span><br><span class="line"></span><br><span class="line">sess.add_all([T1Foo(data=<span class="string">'t1'</span>), T1Foo(data=<span class="string">'t2'</span>), T2Foo(data=<span class="string">'t3'</span>),</span><br><span class="line">             T1Foo(data=<span class="string">'t4'</span>)])</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> sess.query(T1Foo).all()</span><br><span class="line"><span class="keyword">print</span> sess.query(T2Foo).all()</span><br></pre></td></tr></table></figure>
<p>使用了继承的方法，抽象的好，但我们之前的问题解决了吗？没有。还是需要预定义好所有表的model类，才能正确使用，迫不得已，我们只能自己想办法了。</p>
<h2 id="函数方法解决">函数方法解决</h2><p>经过一番探索，我得出了如下方法:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class_registry = &#123;&#125;                                                                                                                                                                    </span><br><span class="line">DbBase = declarative_base(bind=engine, class_registry=class_registry)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_model</span><span class="params">(modelname, tablename, metadata=DbBase.metadata)</span>:</span></span><br><span class="line">    <span class="string">"""</span><br><span class="line">        args:</span><br><span class="line">            modelname:新model名，string类型</span><br><span class="line">            tablename:数据库中表名</span><br><span class="line">        usage:</span><br><span class="line">          RecordDao = get_model("RecordDao_201406", "record_201406")</span><br><span class="line">    """</span></span><br><span class="line">    <span class="keyword">if</span> modelname <span class="keyword">not</span> <span class="keyword">in</span> class_registry: </span><br><span class="line">        model = type(modelname, (DbBase,), dict(</span><br><span class="line">            __table__ = Table(tablename, metadata, autoload=<span class="keyword">True</span>)</span><br><span class="line">        ))  </span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        model = class_registry[modelname]</span><br><span class="line"><span class="keyword">return</span> model</span><br></pre></td></tr></table></figure>
<p>每次想获取对应月表数据的<em>model</em>，调用<em>get_model</em>方法即可。这个方法一直沿用到现在，虽然有点丑陋，但却是解决了以上问题。直到sqlalchemy 0.9.1版本推出<em>Automap</em></p>
<h2 id="Automap方法">Automap方法</h2><p>sqlalchemy文档完备，具体可点击<a href="http://docs.sqlalchemy.org/en/rel_1_0/orm/extensions/automap.html" target="_blank" rel="external">Automap</a>，它可以自动映射数据库的表，通过数据表名映射model，简单直接，实现起来如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> sqlalchemy.ext.automap <span class="keyword">import</span> automap_base</span><br><span class="line"></span><br><span class="line">AutoBase = automap_base()</span><br><span class="line"><span class="comment"># reflect the tables</span></span><br><span class="line">AutoBase.prepare(engine, reflect=<span class="keyword">True</span>)</span><br><span class="line">tablename = <span class="string">"record_201406"</span></span><br><span class="line">RecordDao = getattr(AutoBase.classes, tablename)</span><br></pre></td></tr></table></figure>
<p>这样就可以了，很清晰。但是这个方法有一个缺点，<em>Automap</em>的映射虽然是自动的，但是只有在启动的时候生效，也就是说如果新建一个数据表，而没有告诉<em>Automap</em>，那这个表是找不到的。在实际使用中，可以捕获AttributeError异常，并再次调用<code>AutoBase.prepare(engine, reflect=True)</code> 刷新映射关系。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="背景">背景</h2><p>话说sqlalchemy真是一个非常好用的库，python orm基本上是舍我其谁了，文档还非常全面，基本上没有什么硬伤，现在也冲出了1.0版本，未来更加值得期待。<br>我最早用django orm，不过很快就觉得很多功能不够用，我当]]>
    </summary>
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="sqlalchemy" scheme="http://yoursite.com/tags/sqlalchemy/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[我为什么写博客?]]></title>
    <link href="http://yoursite.com/2015/06/17/%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E5%86%99%E5%8D%9A%E5%AE%A2/"/>
    <id>http://yoursite.com/2015/06/17/我为什么写博客/</id>
    <published>2015-06-17T11:05:26.000Z</published>
    <updated>2015-08-03T13:36:06.000Z</updated>
    <content type="html"><![CDATA[<p>我以前也有写技术博客的习惯，在csdn上，解决一个问题写一篇，有些工具的使用方式也放上边，比较有规律。</p>
<p>后来换了工作，开始比较忙，就扔下了，等闲下来想写，又觉得不好意思了。那时候眼界宽了，看过很多大牛写的文章，觉得自己写的这么浅显，有点拿不出手，想厚积薄发再写。然后就到了现在，对于写博客来说又有了新认识，所以又准备重新捡起这个习惯。</p>
<p>首先，自己确实有刚需。有的技术问题虽然解决了，但是下次遇到了，细节问题又要重新检索，时间成本高，最好还是找个地方记录。另外，在检索信息的过程中，正是很多博客的内容给了我很多指引，解决了问题，写了博客也可以帮助他人，也算是回馈技术圈的一种方式。写博客还有一种好处就是加深认识，提高表述能力。平时对很多问题确实是有了新的理解，但让我写出来，讲给他人，那还得再深思熟虑一番，这个过程对博主是很有帮助的。这段时间深有体会，才想起来还是要再写博客，至于写得是不是有独到见解，是不是拿得出手，其实也没那么重要，都是自己成长的过程。</p>
<p>本篇作为新博客第一篇，既为了开篇，也为了纪念。至于为什么用了<strong><em>githup page + hexo</em></strong>，确实是为了可定制、免费、省心。另外<a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="external">NexT</a>的主题满足了我的所有需求，如果你喜欢我的博客样式，可以尝试一下。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>我以前也有写技术博客的习惯，在csdn上，解决一个问题写一篇，有些工具的使用方式也放上边，比较有规律。</p>
<p>后来换了工作，开始比较忙，就扔下了，等闲下来想写，又觉得不好意思了。那时候眼界宽了，看过很多大牛写的文章，觉得自己写的这么浅显，有点拿不出手，想厚积薄发再写]]>
    </summary>
    
  </entry>
  
</feed>