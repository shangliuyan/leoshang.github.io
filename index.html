<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="Leo Shang 的 BLOG" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="永远年轻, 永远热泪盈眶">
<meta property="og:type" content="website">
<meta property="og:title" content="Leo Shang 的 BLOG">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Leo Shang 的 BLOG">
<meta property="og:description" content="永远年轻, 永远热泪盈眶">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Leo Shang 的 BLOG">
<meta name="twitter:description" content="永远年轻, 永远热泪盈眶">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/"/>

  <title> Leo Shang 的 BLOG </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Leo Shang 的 BLOG</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">随笔</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/10/20/当我们在谈论配置终端，我们在谈些什么/" itemprop="url">
                  当我们在谈论配置终端，我们在谈些什么
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-10-20T01:53:45+08:00" content="2016-10-20">
              2016-10-20
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/10/20/当我们在谈论配置终端，我们在谈些什么/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/10/20/当我们在谈论配置终端，我们在谈些什么/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="当我们在谈论终端时，我们在谈些什么">当我们在谈论终端时，我们在谈些什么</h2><p>程序员经常使用终端，甚至只在终端下工作，那么终端的顺手程度就很重要了。不可避免的，大多数程序员都掌握了配置终端的技巧，但从目前我看到的文章来看，没有比较系统的总结。本文试图通过梳理终端相关的背景知识，整理一个清晰的配置脉络。</p>
<h4 id="我们配置的是终端，还是shell？">我们配置的是终端，还是shell？</h4><p>通常我们说配置终端的时候，其实隐含的意思是配置shell解释器和终端（terminal），以及常用软件（ls，grep）。为什么这三者都要配置呢？什么配置是属于shell解释器的，什么是由终端软件管理的，什么是软件的配置呢？</p>
<p>想要弄明白这些问题，就需要我们知道他们之间的关系。</p>
<p> <img src="/img/Stdstreams-notitle.svg" alt="Stdstreams-notitle"></p>
<p>shell解释器是terminal进程的一个子进程，shell解释器通过标准输入和标准输出与terminal设备文件交互的，在shell下运行的软件，是shell的子进程，也是通过标准输入输出和terminal设备文件进行交互。值得一提，在类UNIX下，虚拟终端也是一个设备，设备文件形如<em>/dev/ttys</em>。</p>
<p>明白这个关系，我们就知道配置的边界了。比如我想修改一下显示的字体，很显然，shell的标准输出不可能输出字体格式的，我们需要在terminal的配置里找到字体配置需要的字体。</p>
<blockquote>
<p>需要注意的是，shell解释器并不特指bash，一台类UNIX操作系统，往往可以支持多种shell解释器。通过<code>cat /etc/shells</code> 可以查看本机支持的shell解释器。另外，不同shell解释器的配置文件也不一样，以bash为例，<em>~/.bash_profile ~/.bashrc</em>是它的配置文件，而zsh则是<em>~/.zsh_profile ~/.zshrc</em></p>
</blockquote>
<h4 id="颜色是怎么显示出来的？">颜色是怎么显示出来的？</h4><p>毫无疑问，配置终端的重点在于颜色搭配和语法高亮。既然终端和进程交互是标准输入输出，那标准输出可不可以输出颜色属性呢？</p>
<p>答案是:<a href="https://en.wikipedia.org/wiki/ANSI_escape_code" target="_blank" rel="external">ANSI转义序列(escape code)</a> 。形如:ESC+[（一般显示为 ^[[）的字符序列可实现在屏幕上定位光标、改变输出字符颜色等功能。例如在bash中， <code>ESC</code> 字符可以用一下三种转义形式输出:</p>
<ul>
<li><code>\e</code></li>
<li><code>\033</code></li>
<li><code>\x1B</code></li>
</ul>
<p>我们可以用”<esc>[<em>Color Code</em>m”    的形式输出颜色，例如：</esc></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">printf &quot;Default \e[91mLight red&quot;</div></pre></td></tr></table></figure>
<p>终端的显示为：</p>
<p> <img src="/img/term_color.png" alt="terminal color"></p>
<p>同理，所谓的终端提示符颜色，以及各种软件结果的输出，只要加上颜色转义，就会被终端显示为对应的颜色。理论上，我们任何的输出都可以自定义颜色，例如下面的方法，将make日志的不同级别分颜色打印出来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">make 2&gt;&amp;1 | sed -e &apos;s/.*\bWARN.*/\x1b[7m&amp;\x1b[0m/i&apos; -e &apos;s/.*\bERR.*/\x1b[93;41m&amp;\x1b[0m/i&apos;</div></pre></td></tr></table></figure>
<p>了解到这些，就明白为什么 <em>ls</em> 指令为什么默认没有颜色，但 <em>ls -G</em> 就有颜色了，输出加入颜色转义了嘛。</p>
<h4 id="我们需要配置终端的什么？">我们需要配置终端的什么？</h4><p>下面我列了下，一般我们需要做的配置清单</p>
<ul>
<li><p>字体字号</p>
<ul>
<li>字体：推荐苹果的两代字体 Monaco和Menlo，Monaco第一眼看起来真是惊艳，但普遍反映Menlo更加耐看一点</li>
<li>字号：视个人情况而定，个人偏向15号</li>
<li>在终端配置文件中修改，以osx为例，<em>终端&gt;偏好设置&gt;描述文件&gt;文本&gt;字体</em></li>
</ul>
</li>
<li><p>颜色</p>
<ul>
<li><p>终端背景颜色或图片</p>
<ul>
<li>和修改字体一样，在终端配置文件中修改，以osx为例，<em>终端&gt;偏好设置&gt;描述文件&gt;文本&gt;字体</em></li>
</ul>
</li>
<li><p>终端颜色支持</p>
<ul>
<li><p>这点确实要特别注意，我们使用的终端实际上是伪终端或者叫模拟终端，所以这个软件是可以模拟多种上古终端的，但是不改声明的话，他默认模拟的终端一般都是支持8*2种颜色，那我们其他配置再眼花缭乱也没有，这个终端只能显示16种颜色</p>
<p> <img src="/img/term_config.png" alt="term_config"></p>
<p>所以这个地方一定要声明为256color的！！！</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>prompt提示符</p>
<ul>
<li><p>prompt提示符是shell解释器的输出，所以需要修改shell解释器配置文件</p>
</li>
<li><p>以bash为例：在<em>~/.bash_profile</em> 中修改PS1环境变量即可。例如：</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">export PS1=&quot;\[\033[36m\]\u\[\033[m\]@\[\033[32m\]\h:\[\033[33;1m\]\w\[\033[m\]\$ &quot;</div></pre></td></tr></table></figure>
</li>
<li><p>更详细定制的配置方法网上很多，参见<a href="https://linuxconfig.org/bash-prompt-basics" target="_blank" rel="external">https://linuxconfig.org/bash-prompt-basics</a></p>
</li>
<li><p>推荐一个可拖动的网站，<a href="http://bashrcgenerator.com/" target="_blank" rel="external">http://bashrcgenerator.com/</a></p>
</li>
</ul>
</li>
<li><p>editor（vim，emac）</p>
<ul>
<li><p>同理，编辑器的输出设置要在编辑器的配置文件中设置，~/.vimrc中 配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">colorscheme theme</div></pre></td></tr></table></figure>
</li>
<li><p>vim 自带多种主题可供选择，路径为 <em>/usr/share/vim/vim7x/colors</em></p>
</li>
<li><p>推荐一个vim的主题网站，<a href="http://vimcolors.com/" target="_blank" rel="external">http://vimcolors.com/</a><br>主题下载后放入~/.vim/colors中，修改vimrc配置即可使用</p>
</li>
</ul>
</li>
<li><p>常用软件（ls, grep, tmux）</p>
<ul>
<li>像ls这种常用软件，颜色格式的输出是有必要的，但是每个软件的配置不太一样，ls需要配置LSCOLORS环境变量，而grep的环境变量是GREP_COLOR</li>
</ul>
</li>
</ul>
<ul>
<li><p>别名</p>
<ul>
<li><p>这个根据个人习惯，比较通用的比如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alias ll=&quot;ls -hlF&quot;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h4 id="但是我只想选择">但是我只想选择</h4><p>说了这么多，可能对于很多人来说（比如前段开发），并不需要了解这些，只想用的舒服就好了，有没有简单的方式只要点几下就可以做出一个很完善的终端呢？当然可以…</p>
<ul>
<li><p>终端</p>
<p> <img src="/img/term_file.png" alt="term_file"></p>
<p>以osx默认终端为例，我们可以看到其实所有配置都在一个叫“描述文件”的选项中，并且，我们可以看到下边的设置，描述文件是可以导出的，那么毫无疑问，github上这些描述文件模板会非常多，总有一款适合你。</p>
<p>详情参见<a href="https://github.com/lysyi3m/osx-terminal-themes" target="_blank" rel="external">https://github.com/lysyi3m/osx-terminal-themes</a></p>
<p>见到喜欢的主题，下载后双击或者导入都可以。</p>
<ul>
<li><p>iterm2</p>
<p>如果你想体验更多的配置选项，已经更多拓展功能，可以尝试iterm2，个人觉得分屏功能很不错，用了以后会觉得tmux有点鸡肋了。</p>
</li>
</ul>
</li>
<li><p>选择zsh</p>
<p>选择zsh并不是因为zsh从零开始配置比bash容易很多，而是因为zsh的插件系统，导致网上有很多可供选择的模板，让我们轻松定制。比如</p>
<ul>
<li>oh-my-zsh,  <a href="https://github.com/robbyrussell/oh-my-zsh" target="_blank" rel="external">https://github.com/robbyrussell/oh-my-zsh</a> 只要运行一行安装指令，什么语法高亮，自动补全，不同软件甚至git的配置统统都有了，非常强大。</li>
<li>Prezto,<a href="https://github.com/sorin-ionescu/prezto" target="_blank" rel="external">https://github.com/sorin-ionescu/prezto</a> 如果你觉得oh-my-zsh功能太多，并且有点卡或者有点慢了，可以试试Prezto，这个可以认为是一个速度更快的oh-my-zsh，但是缺陷是插件没有oh-my-zsh多。</li>
</ul>
<p>​</p>
</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/20/Redis实践——前言/" itemprop="url">
                  Redis实践——前言
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-20T21:34:31+08:00" content="2016-06-20">
              2016-06-20
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/06/20/Redis实践——前言/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/06/20/Redis实践——前言/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>现在工作中用redis比较多，为了进度也是用的很随便，一直想做个梳理，总结归纳一下redis使用方法。在这里也是挖个坑，接下来想写一个系列，主要是通过实际的应用出发，姑且记录redis的一些使用经验，希望以后能真正总结出一种套路或者说规范。</p>
<p>大学时我们都学过数据库理论，严格讲应该叫关系数据库理论。经过多年发展, 关系数据库有系统的方法理论，我们常用的梳理关系方法用E-R图，评价标准可以用范式理论。<br>与此相比，nosql由于设计的多样性，使用方法上更多的是和应用场景相关，更多使用依赖个人喜好，这个就造成了一些混乱, 下面我会按照主题，总结下可能出现的一些混乱点，得出一些个人结论。</p>
<p>以下是相关的主题：</p>
<p>基础篇</p>
<ul>
<li>redis提供的数据结构</li>
<li>redis实用特性：事务，pipline，script<br>要使用好redis，其实无外乎两点，第一点，掌握基本数据结构提供的功能和使用场景，这个网上内容很多，概念不想多讲，我会在最后的实例篇中进行说明。<br>另外就一个，就是除了数据机构的特性了，这个我简单介绍常用的并且容易混淆的三个特性，事物，pipeline和script。</li>
</ul>
<p>规范篇</p>
<ul>
<li>key名称的设计规范</li>
</ul>
<p>实例篇</p>
<ul>
<li>json和map对比</li>
<li>任务队列的设计</li>
<li>队列消费方式对比</li>
<li>任务调度服务设计(zset)</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/15/python2-json的大坑/" itemprop="url">
                  python2 json的大坑
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-15T21:59:57+08:00" content="2016-06-15">
              2016-06-15
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/06/15/python2-json的大坑/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/06/15/python2-json的大坑/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="介绍一下背景">介绍一下背景</h2><p>最近项目中有一个接口，是通过redis队列做的。我将对方需要的数据通过json 字符串的形式，push到redis list队列中，对方监听并消费(题外话, 我对这种形式的交互有点看法吧，双方既然是接口，但是很难保证格式的统一，比使用rpc框架强验证风险大的多)。</p>
<p>由于对端也是用python做的消费者，所以也是相安无事。随着一个需求的变更，我在自己调试pop的数据发现，我写的json字符串是，酱事儿的:<br><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;<span class="attr">"title"</span>: <span class="string">"\\u6211\\u7231\\u5317\\u4eac\\u5929\\u5b89\\u95e8"</span>&#125;</div></pre></td></tr></table></figure></p>
<p>当时我就懵逼了，这是什么鬼…<br>很显然这个是unicode字符串嘛，但是我明明就编码成了UTF8啦，怎么最后是这个鬼样子，更奇怪的是对方能正确解码吗？这明明是四不像啊。</p>
<p>我试着自己重现了整个过程。<br>首先，我将utf8形式的字符串 <em>我爱北京天安门</em> dumps成json:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">In [<span class="number">10</span>]: json.dumps(&#123;<span class="string">"title"</span>:<span class="string">"我爱北京天安门"</span>&#125;)</div><div class="line">Out[<span class="number">10</span>]: <span class="string">'&#123;"title": "\\u6211\\u7231\\u5317\\u4eac\\u5929\\u5b89\\u95e8"&#125;'</span></div></pre></td></tr></table></figure></p>
<p>果然，确实变成了这个样子，看来是json库搞得鬼。<br>先不管他，看看这个结果load出来什么样子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">In [<span class="number">9</span>]: json.loads(<span class="string">'&#123;"title": "\\u6211\\u7231\\u5317\\u4eac\\u5929\\u5b89\\u95e8"&#125;'</span>)</div><div class="line">Out[<span class="number">9</span>]: &#123;<span class="string">u'title'</span>: <span class="string">u'\u6211\u7231\u5317\u4eac\u5929\u5b89\u95e8'</span>&#125;</div></pre></td></tr></table></figure></p>
<p>确实load没问题，但是可以看到，最后的结果和我当时dumps的出入蛮大的，由原来的utf8 str形式，变为了unicode形式，就连字典的key也都是unicode了。</p>
<p>好吧，所以现在就有了两个问题。</p>
<ul>
<li>为什么utf8字符串, json dumps后不是原来形式?</li>
<li>为什么loads回来的数据全是unicode形式？</li>
</ul>
<h2 id="为什么utf8字符串,_json_dumps后不是原来形式?">为什么utf8字符串, json dumps后不是原来形式?</h2><p>看下官方文档：<br><img src="/img/python_encode.png" alt="python encode"><br>json.dumps方法做的就是将python数据格式按照上图的映射方式转换为json格式。Python str和unicode都可以转换成json 的string形式，我们知道str和unicode差别很大啊，如果一个python字典中，同时有str和unicode的时候，json dump怎么处理呢？试一下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">In [<span class="number">12</span>]: json.dumps(&#123;<span class="string">"title_str"</span>:<span class="string">"我爱北京天安门"</span>, <span class="string">"title_unicode"</span>:<span class="string">u"我爱北京天安门"</span>&#125;)</div><div class="line">Out[<span class="number">12</span>]: <span class="string">'&#123;"title_unicode": "\\u6211\\u7231\\u5317\\u4eac\\u5929\\u5b89\\u95e8", "title_str": "\\u6211\\u7231\\u5317\\u4eac\\u5929\\u5b89\\u95e8"&#125;'</span></div></pre></td></tr></table></figure></p>
<p>没有异常，并且都是最后按照unicode的方式统一处理的。看来python是先将str decode为unicode，然后再用unicode进行编码的。</p>
<p><strong>这样本来无可厚非，自己统一好编码格式就行了，loads的时候按照编码的方式，反过来解码。但是问题是，和我们进行交互的人未必也用的python啊，当他用其他的语言对json解码的时候，还原回来就是一堆乱码了，我们能不能让json库，确实编码成utf8形式呢？</strong></p>
<p>官方文档如是说：</p>
<blockquote>
<p>If ensure_ascii is True (the default), all non-ASCII characters in the output are escaped with \uXXXX sequences, and the results are str instances consisting of ASCII characters only. If ensure_ascii is False, a result may be a unicode instance. This usually happens if the input contains unicode strings or the encoding parameter is used.</p>
</blockquote>
<p>看来是 ensure_ascii 参数为 True 的时候，确保了所有非ASCII字符都转义成 \uXXXX 的ASCII序列。<br>如果我们设置为False，就可以还原本来面目了吗？试试：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">In [<span class="number">14</span>]: json.dumps(&#123;<span class="string">"title_str"</span>:<span class="string">"我爱北京天安门"</span>&#125;, ensure_ascii=<span class="keyword">False</span>)</div><div class="line">Out[<span class="number">14</span>]: <span class="string">'&#123;"title_str": "\xe6\x88\x91\xe7\x88\xb1\xe5\x8c\x97\xe4\xba\xac\xe5\xa4\xa9\xe5\xae\x89\xe9\x97\xa8"&#125;'</span></div></pre></td></tr></table></figure></p>
<p>果然哦，我们干脆看看python json库源码怎么实现的吧, 主要就是下列这个判断 </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="number">200</span> <span class="keyword">if</span> self.ensure_ascii:</div><div class="line"><span class="number">201</span>     <span class="keyword">return</span> encode_basestring_ascii(o) <span class="comment"># 先将字符串根据encoding参数的编码统一转化为unicode，然后连接字符串</span></div><div class="line"><span class="number">202</span> <span class="keyword">else</span>:</div><div class="line"><span class="number">203</span>     <span class="keyword">return</span> encode_basestring(o) <span class="comment"># 直接连接字符串</span></div></pre></td></tr></table></figure>
<p>既然ensure_ascii = False时, 没有做类型的转换，所以我们原来是什么，编码后就是什么。但这带来了以下副作用:</p>
<ul>
<li><p>如果我们要转换的python数据类型，如果既包含str又包含unicode，在连接字符串的时候肯定会抛出编码异常</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">In [<span class="number">13</span>]: json.dumps(&#123;<span class="string">"title_str"</span>:<span class="string">"我爱北京天安门"</span>, <span class="string">"title_unicode"</span>:<span class="string">u"我爱北京天安门"</span>&#125;, ensure_ascii=<span class="keyword">False</span>)</div><div class="line"><span class="string">"UnicodeDecodeError: 'ascii' codec can't decode byte 0xe6 in position 1: ordinal not in range(128)"</span></div></pre></td></tr></table></figure>
</li>
<li><p>如果全部都是unicode进行字符串连接，返回值也是unicode</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">In [<span class="number">3</span>]: json.dumps(&#123;<span class="string">"title_str"</span>:<span class="string">u"我爱北京天安门"</span>, <span class="string">"title"</span>:<span class="string">u"我爱世界"</span>&#125;, ensure_ascii=<span class="keyword">False</span>)</div><div class="line">Out[<span class="number">3</span>]: <span class="string">u'&#123;"title": "\u6211\u7231\u4e16\u754c", "title_str": "\u6211\u7231\u5317\u4eac\u5929\u5b89\u95e8"&#125;'</span></div></pre></td></tr></table></figure>
</li>
<li><p>如果全部都是str进行字符串连接，返回值也是str</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">In [<span class="number">2</span>]: json.dumps(&#123;<span class="string">"title_str"</span>:<span class="string">"我爱北京天安门"</span>, <span class="string">"title"</span>:<span class="string">"我爱世界"</span>&#125;, ensure_ascii=<span class="keyword">False</span>)</div><div class="line">Out[<span class="number">2</span>]: <span class="string">'&#123;"title": "\xe6\x88\x91\xe7\x88\xb1\xe4\xb8\x96\xe7\x95\x8c", "title_str": "\xe6\x88\x91\xe7\x88\xb1\xe5\x8c\x97\xe4\xba\xac\xe5\xa4\xa9\xe5\xae\x89\xe9\x97\xa8"&#125;'</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>为了能将json字符串通用的和其他语言交换，我们不得不保证，原始python数据类型必须是统一的。要么全是UTF8的str类型，要么全部是unicode，最后在encode为utf8, 否则就会有异常</strong> 这个也是动态类型要付出的代价吧。</p>
<h2 id="为什么loads回来的数据全是unicode形式？">为什么loads回来的数据全是unicode形式？</h2><p>看下官方文档：<br><img src="/img/python_decode.png" alt="python decode"><br>与dumps相反, json.loads 方法做的就是将json数据格式按照上图的映射方式转换为python类型。我们可以看json string 转换回来只有一种格式，那就是unicode，这样就能解释我们看到的现象了，就连dict key都是unicode的。</p>
<h2 id="好麻烦啊，怎么根本的解决这个问题呢？">好麻烦啊，怎么根本的解决这个问题呢？</h2><p><strong>答： 使用python3 </strong></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/07/19/tornado的网络模型/" itemprop="url">
                  tornado的网络模型
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-07-19T18:36:45+08:00" content="2015-07-19">
              2015-07-19
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2015/07/19/tornado的网络模型/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/07/19/tornado的网络模型/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在网站逐步发展的过程中，很可能就会遇到<a href="http://www.kegel.com/c10k.html" target="_blank" rel="external">C10K</a>问题，python中一个比较流行的解决方式是通过tornado这个web server解决。<br>tornado是一个非阻塞的Web服务器，下面我会结合源码，对tornado进行一下结构来说明。</p>
<h2 id="基础理论">基础理论</h2><p>在这之前，我们需要先弄清楚几个概念，便于我们理解tornado。</p>
<ul>
<li>同步、异步、阻塞和非阻塞这几个概念的区别和联系。这个问题网上内容很多，可以看下<a href="http://www.zhihu.com/question/19732473" target="_blank" rel="external">知乎这个问题的讨论</a>，个人认为还是不错的，几个高票的回答从不同角度说明了问题，看过后应该会有比较清晰的认识。</li>
<li>epoll的原理。这个是tornado的核心，在网上前人说了很多。我推荐这个[知乎讨论]（<a href="http://www.zhihu.com/question/20122137）,@蓝形参和@张亚伟的回答结合看，应该就能理解大概的原理" target="_blank" rel="external">http://www.zhihu.com/question/20122137）,@蓝形参和@张亚伟的回答结合看，应该就能理解大概的原理</a></li>
</ul>
<h2 id="核心模块">核心模块</h2><p>tornado的核心模块分为三部分：</p>
<ul>
<li>httpserver - 服务于 web 模块的一个非常简单的 HTTP 服务器的实现</li>
<li>iostream - 对非阻塞式的 socket 的简单封装，以方便常用读写操作</li>
<li>ioloop - 核心的 I/O 循环</li>
</ul>
<p>我们结合tornado官网的<em>hello world</em>，看看整个过程到底是怎么进行的。<br>hello_world.py:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> tornado.httpserver</div><div class="line"><span class="keyword">import</span> tornado.ioloop</div><div class="line"><span class="keyword">import</span> tornado.web</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainHandler</span><span class="params">(tornado.web.RequestHandler)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></div><div class="line">        self.write(<span class="string">"Hello, world"</span>)</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">    application = tornado.web.Application([</div><div class="line">        (<span class="string">r"/"</span>, MainHandler),</div><div class="line">    ])</div><div class="line">    http_server = tornado.httpserver.HTTPServer(application)</div><div class="line">    http_server.listen(<span class="number">8888</span>)                                                                                                                              </div><div class="line">    tornado.ioloop.IOLoop.instance().start()</div></pre></td></tr></table></figure>
<p>当我们运行python hello_world.py，先实例化一个tornado.web.Application实例<em>application</em>(这个类并不是核心范畴，所以在这里暂且不做说明，可以简单理解为对数据请求进行url路由，并且生成返回数据的一个handler。在hello_world.py中，我们对根目录url的请求，返回“hello world”内容的数据)。</p>
<p>然后将<em>application</em>作为参数，实例化tornado.httpserver.HTTPServer，赋值给http_server，http_server再调用listen方法。<br>这个过程发生了什么，我们来看看httpserver.py。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, request_callback, no_keep_alive=False, io_loop=None,</span></span></div><div class="line">             xheaders=False, ssl_options=None):</div><div class="line">    <span class="string">"""Initializes the server with the given request callback.</span></div><div class="line"></div><div class="line">    If you use pre-forking/start() instead of the listen() method to</div><div class="line">    start your server, you should not pass an IOLoop instance to this</div><div class="line">    constructor. Each pre-forked child process will create its own</div><div class="line">    IOLoop instance after the forking process.</div><div class="line">    """</div><div class="line">    self.request_callback = request_callback</div><div class="line">    self.no_keep_alive = no_keep_alive</div><div class="line">    self.io_loop = io_loop</div><div class="line">    self.xheaders = xheaders</div><div class="line">    self.ssl_options = ssl_options</div><div class="line">    self._socket = <span class="keyword">None</span></div><div class="line">    self._started = <span class="keyword">False</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">listen</span><span class="params">(self, port, address=<span class="string">""</span>)</span>:</span></div><div class="line">    <span class="string">"""Binds to the given port and starts the server in a single process.</span></div><div class="line"></div><div class="line">    This method is a shortcut for:</div><div class="line"></div><div class="line">        server.bind(port, address)</div><div class="line">        server.start(1)</div><div class="line"></div><div class="line">    """</div><div class="line">    self.bind(port, address)</div><div class="line">    self.start(<span class="number">1</span>)</div></pre></td></tr></table></figure>
<p>实例化方法除了将<em>application</em>赋值为request_callback外，都是使用的默认值，注意这里<em>io_loop=None</em>。listen方法比较简单，绑定socket然后调用start方法。start方法代码比较多，只看主要逻辑。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> <span class="keyword">not</span> self.io_loop:</div><div class="line">    self.io_loop = ioloop.IOLoop.instance()</div><div class="line">self.io_loop.add_handler(self._socket.fileno(),</div><div class="line">                         self._handle_events,</div><div class="line">                         ioloop.IOLoop.READ)</div></pre></td></tr></table></figure>
<p>终于出现io_loop，在实例化httpserver的时候io_loop=None，这里将ioloop.IOLoop.instance()赋值给ioloop。值得一提的是ioloop采用单实例模式，所以ioloop.IOLoop.instance()就是返回ioloop的实例。现在跳转到ioloop.py。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_handler</span><span class="params">(self, fd, handler, events)</span>:</span></div><div class="line">    <span class="string">"""Registers the given handler to receive the given events for fd."""</span></div><div class="line">    self._handlers[fd] = handler</div><div class="line">    self._impl.register(fd, events | self.ERROR)</div></pre></td></tr></table></figure>
<p>可以看到add_handler方法将fd文件描述符和events事件注册到_impl上，这个_impl可以认为是epoll类（根据操作系统不同可能为kqueue），另外将handler赋值给self._handlers[fd]，_handlers[fd]相当于文件描述符和回调函数对应的字典，当事件触发的时候会调用。回到httpserver.py，我们调用的是</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">self.io_loop.add_handler(self._socket.fileno(),</div><div class="line">                         self._handle_events,</div><div class="line">                         ioloop.IOLoop.READ)</div></pre></td></tr></table></figure>
<p>文件描述符是监听端口的socket，事件READ可以认为I/O是数据读取就绪，回调函数为self._handle_events:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">_handle_events</span><span class="params">(self, fd, events)</span>:</span>                                                                                                                     </div><div class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            connection, address = self._socket.accept()</div><div class="line">        <span class="keyword">except</span> socket.error, e:</div><div class="line">            <span class="keyword">if</span> e[<span class="number">0</span>] <span class="keyword">in</span> (errno.EWOULDBLOCK, errno.EAGAIN):</div><div class="line">                <span class="keyword">return</span></div><div class="line">            <span class="keyword">raise</span></div><div class="line">        <span class="keyword">if</span> self.ssl_options <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</div><div class="line">            <span class="keyword">assert</span> ssl, <span class="string">"Python 2.6+ and OpenSSL required for SSL"</span></div><div class="line">            connection = ssl.wrap_socket(</div><div class="line">                connection, server_side=<span class="keyword">True</span>, **self.ssl_options)</div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            stream = iostream.IOStream(connection, io_loop=self.io_loop)</div><div class="line">            HTTPConnection(stream, address, self.request_callback,</div><div class="line">                           self.no_keep_alive, self.xheaders)</div><div class="line">        <span class="keyword">except</span>:</div><div class="line">            logging.error(<span class="string">"Error in connection callback"</span>, exc_info=<span class="keyword">True</span>)</div></pre></td></tr></table></figure>
<p>现在我们可以梳理一下整个过程，httpserver监听一个端口，并把这个文件描述符通过ioloop注册到epoll，只要收到请求，epoll回调_handle_events方法。这个方法做了什么呢？<br>根据请求数据，创建了一个socket连接<em>connection</em>，然后将这个connection作为文件描述符实例化另一个核心模块<em>iostream</em>，赋值为steam，然后使用steam和self.request_callback(tornado.web.Application实例的<em>application</em>)作为主要参数，实例HTTPConnection。<br>HTTPConnection负责HTTP协议部分，它的I/O使用iostream，通过iostream read方法读取数据解析数据包，然后调用application生成返回数据，在调用iostream write方法将数据返回。这个过程的I/O事件注册就靠iostream.<br>我们看下实例iostream的代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, socket, io_loop=None, max_buffer_size=<span class="number">104857600</span>,</span></span></div><div class="line">             read_chunk_size=<span class="number">4096</span>):</div><div class="line">    self.socket = socket</div><div class="line">    self.socket.setblocking(<span class="keyword">False</span>)</div><div class="line">    self.io_loop = io_loop <span class="keyword">or</span> ioloop.IOLoop.instance()</div><div class="line">    self.max_buffer_size = max_buffer_size</div><div class="line">    self.read_chunk_size = read_chunk_size</div><div class="line">    self._read_buffer = <span class="string">""</span></div><div class="line">    self._write_buffer = <span class="string">""</span></div><div class="line">    self._read_delimiter = <span class="keyword">None</span></div><div class="line">    self._read_bytes = <span class="keyword">None</span></div><div class="line">    self._read_callback = <span class="keyword">None</span></div><div class="line">    self._write_callback = <span class="keyword">None</span></div><div class="line">    self._close_callback = <span class="keyword">None</span></div><div class="line">    self._state = self.io_loop.ERROR                                                                                                                      </div><div class="line">    self.io_loop.add_handler(</div><div class="line">        self.socket.fileno(), self._handle_events, self._state)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_until</span><span class="params">(self, delimiter, callback)</span>:</span></div><div class="line">    <span class="string">"""Call callback when we read the given delimiter."""</span></div><div class="line">    <span class="keyword">assert</span> <span class="keyword">not</span> self._read_callback, <span class="string">"Already reading"</span></div><div class="line">    loc = self._read_buffer.find(delimiter)</div><div class="line">    <span class="keyword">if</span> loc != <span class="number">-1</span>:</div><div class="line">        self._run_callback(callback, self._consume(loc + len(delimiter)))</div><div class="line">        <span class="keyword">return</span></div><div class="line">    self._check_closed()</div><div class="line">    self._read_delimiter = delimiter</div><div class="line">    self._read_callback = callback</div><div class="line">    self._add_io_state(self.io_loop.READ)</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">write</span><span class="params">(self, data, callback=None)</span>:</span></div><div class="line">    <span class="string">"""Write the given data to this stream.</span></div><div class="line">    """</div><div class="line">    self._check_closed()</div><div class="line">    self._write_buffer += data</div><div class="line">    self._add_io_state(self.io_loop.WRITE)</div><div class="line">    self._write_callback = callback</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">_add_io_state</span><span class="params">(self, state)</span>:</span></div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> self._state &amp; state:</div><div class="line">        self._state = self._state | state</div><div class="line">        self.io_loop.update_handler(self.socket.fileno(), self._state)</div></pre></td></tr></table></figure>
<p>可以看到在实例iostream的时候，我们就将返回给客户端的文件描述符注册到ioloop上，但是事件是ERROR。在write和read_until方法中，都调用了_add_io_state方法，这个方法负责更新对应文件描述符的注册事件。</p>
<p>现在我们来看看tornado所谓的单线程主要的任务调度逻辑，ioloop中start方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">start</span><span class="params">(self)</span>:</span></div><div class="line">    ...</div><div class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">    ...</div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            event_pairs = self._impl.poll(poll_timeout)</div><div class="line">        <span class="keyword">except</span> Exception, e:</div><div class="line">            <span class="comment"># Depending on python version and IOLoop implementation,</span></div><div class="line">            <span class="comment"># different exception types may be thrown and there are</span></div><div class="line">            <span class="comment"># two ways EINTR might be signaled:</span></div><div class="line">            <span class="comment"># * e.errno == errno.EINTR</span></div><div class="line">            <span class="comment"># * e.args is like (errno.EINTR, 'Interrupted system call')</span></div><div class="line">            <span class="keyword">if</span> (getattr(e, <span class="string">'errno'</span>) == errno.EINTR <span class="keyword">or</span></div><div class="line">                (isinstance(getattr(e, <span class="string">'args'</span>), tuple) <span class="keyword">and</span></div><div class="line">                 len(e.args) == <span class="number">2</span> <span class="keyword">and</span> e.args[<span class="number">0</span>] == errno.EINTR)):</div><div class="line">                logging.warning(<span class="string">"Interrupted system call"</span>, exc_info=<span class="number">1</span>)</div><div class="line">                <span class="keyword">continue</span></div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                <span class="keyword">raise</span></div><div class="line">    ...</div><div class="line">        self._events.update(event_pairs)</div><div class="line">        <span class="keyword">while</span> self._events:</div><div class="line">            fd, events = self._events.popitem()</div><div class="line">            <span class="keyword">try</span>:</div><div class="line">                self._handlers[fd](fd, events)</div><div class="line">            <span class="keyword">except</span> (KeyboardInterrupt, SystemExit):</div><div class="line">                <span class="keyword">raise</span></div><div class="line">            <span class="keyword">except</span> (OSError, IOError), e:</div><div class="line">                <span class="keyword">if</span> e[<span class="number">0</span>] == errno.EPIPE:</div><div class="line">                    <span class="comment"># Happens when the client closes the connection</span></div><div class="line">                    <span class="keyword">pass</span></div><div class="line">                <span class="keyword">else</span>:</div><div class="line">                    logging.error(<span class="string">"Exception in I/O handler for fd %d"</span>,</div><div class="line">                                  fd, exc_info=<span class="keyword">True</span>)</div><div class="line">            <span class="keyword">except</span>:</div><div class="line">                logging.error(<span class="string">"Exception in I/O handler for fd %d"</span>,</div><div class="line">                              fd, exc_info=<span class="keyword">True</span>)</div></pre></td></tr></table></figure>
<p>在这里 <code>event_pairs = self._impl.poll(poll_timeout)</code>，陷入epoll，然后<code>while self._events</code>之后的代码，运行触发事件后回调函数。<br>现在我们通过一张图看看整个流程：<br><img src="/img/tornado-httpserver.png" alt="tornado-httpserver图"></p>
<h2 id="还有什么">还有什么</h2><p>我们看到在tornado中，无论运行什么库，只要涉及I/O，都要注册到ioloop上，这样才能发挥异步I/O的作用，否则tornado也会阻塞。所以tornado会有很多第三方库，所以在实际使用中，我们有必要学习一下第三方库的使用。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/07/06/python的协程/" itemprop="url">
                  python的协程
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-07-06T15:18:35+08:00" content="2015-07-06">
              2015-07-06
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2015/07/06/python的协程/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/07/06/python的协程/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>关于python的协程，网上资料还是挺多的，这里说一下我的理解吧。</p>
<h2 id="什么是协程？">什么是协程？</h2><p>先看一下wiki的定义吧</p>
<blockquote>
<p>Coroutines are computer program components that generalize subroutines for nonpreemptive multitasking, by allowing multiple entry points for suspending and resuming execution at certain locations.</p>
</blockquote>
<p>这个定义不太容易理解。一句话可能很难直观的说明协程这个概念，通俗讲，协程是由一系列的子程序协同完成一个任务，这些子程序可以主动挂起交出控制权，当恢复执行的时候，可以从挂起的位置继续执行，而这一切的调度由用户操作，而不是操作系统。所以有人称，<em>协程是用户态线程</em>。<br>协程的实现并不与操作系统相关，是语言相关的，所以可以看到主流的一些语言都有协程的实现，包括java，go等。在python中，协程是通过生成器实现的，<em>yeild</em>就可以保存当前子程序上下文，并交出控制权，使用send就可以传递数据并恢复相应子程序。这样多个生成器子程序，就可以通过yield和send相互协作完成任务。</p>
<h2 id="python的协程和生成器的关系">python的协程和生成器的关系</h2><p>说到这里，可能会产生疑问，使用<em>yield</em>的函数不是生成器么？生成器就是协程么？确实如此，参见<a href="https://www.python.org/dev/peps/pep-0342/" target="_blank" rel="external">PEP 342</a>，在python 2.5以前生成器就是仅仅是迭代器函数，可以生成无限列表。但是yield保存上下文，主动交出控制权的特性已经很接近协程了，所以在python 2.5对生成器进行了几个改进：</p>
<ul>
<li>yield从语句变为表达式, 这个是为了传值方便</li>
<li>加入send()方法用于在恢复生成器的时候，传入值</li>
<li>加入close()方法用于结束协程</li>
<li>加入throw()方法用于传入异常<br>加入了send()和throw()方法，我们就可以在协程恢复的时候，传入值或者异常。有了这些特性，python从语言上就支持基本的协程功能了，当然对不同协程的控制，还要用户自己来编写。所以我们可以说，从python 2.5以后的生成器才可以用于作为协程。</li>
</ul>
<h2 id="与greenlet，gevent的关系">与greenlet，gevent的关系</h2><p>介绍完python在语义上对协程的支持，但实际使用中会发现，很少有用生成器方式的协程，一般用greenlets，gevent这样的package代替。为什么会这样呢？主要还是因为python2.x对协程的支持有限，要支持复杂的应用比较困难，但是在python3以后，协程会更加好用，我们看看python对协程的支持历程：</p>
<blockquote>
<p>Implementations for Python</p>
<ul>
<li>Python 2.5 implements better support for coroutine-like functionality, based on extended generators (PEP 342)</li>
<li>Python 3.3 improves this ability, by supporting delegating to a subgenerator (PEP 380)</li>
<li>Python 3.4 introduces a comprehensive asynchronous I/O framework as standardized in PEP 3156, which includes coroutines that leverage subgenerator delegation</li>
<li>Python 3.5 introduces explicit support for coroutines with async/await syntax (PEP 0492).</li>
</ul>
</blockquote>
<p>到Python 3.5都已经有明确的异步操作方法了，但是这些都是2.x所不具备的。所以在python2.x时代，就需要其他实现方式作为补充。<br>greenlet就是这样一个库，它是从stackless python中剥离，支持CPython的版本的一个协程模块, 相当于python协程的增强版。在github上有使用greenlet重新实现生成器的<a href="https://github.com/python-greenlet/greenlet/blob/master/tests/test_generator.py" target="_blank" rel="external">demo</a>，大家可以体会一下greenlet的特性。但是和python 生成器协程一样，greenlet也没有控制调度的功能，如果要实现一个非阻塞的操作，还要自己实现控制调度逻辑，这就催生了gevent的产生。</p>
<blockquote>
<p>gevent is a coroutine-based Python networking library that uses greenlet to provide a high-level synchronous API on top of the libev event loop.<br>Features include:</p>
<ul>
<li>Fast event loop based on libev (epoll on Linux, kqueue on FreeBSD).</li>
<li>Lightweight execution units based on greenlet.</li>
<li>API that re-uses concepts from the Python standard library (for example there are Events and Queues).</li>
<li>Cooperative sockets with SSL support »</li>
<li>DNS queries performed through threadpool or c-ares.</li>
<li>Monkey patching utility to get 3rd party modules to become cooperative »</li>
</ul>
</blockquote>
<p>gevent在greenlet基础上结合libev作为事件循环，补充了协程要自己写异步调度的空缺，最大化了协程的性能。在此基础上，还提供了多种API，方便开发，甚至直接提供了一个支持协程WSGI server，bottle就支持了这个特性。另外值得一提的是它的<em>Monkey patch</em>，可以无缝将python标准库中阻塞的API包装成非阻塞的，这一特性大大提高了gevent的应用率。</p>
<h2 id="协程带来的改变">协程带来的改变</h2><p>面向对象是和现实世界构成的形式一致的，但是不同对象之间的交互，还是采用调用的关系。调用关系隐含的的是主从关系，但现实世界，很多关系的协作是对等的，比如生产者和消费者。协程就是在计算机程序设计中对这种现实反映的实现。<br>下面我们结合程序简要说明协程的几种应用：</p>
<ul>
<li><p>无限列表<br>  假设一种情形，我们需要所有的斐波那契数列，如果不用协程基本上实现不了吧。协程实现就很方便：</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">()</span>:</span></div><div class="line">     first, second = <span class="number">0</span>, <span class="number">1</span></div><div class="line">     <span class="keyword">yield</span> first</div><div class="line">     <span class="keyword">yield</span> second</div><div class="line">     <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">         third = first + second</div><div class="line">         <span class="keyword">yield</span> third</div><div class="line">         first = second</div><div class="line">         second = third</div></pre></td></tr></table></figure>
</li>
<li><p>管道<br>  如果我们想用python实现管道怎么做呢，答案也是协程。下面这个例子来自于<a href="https://books.google.co.jp/books?id=Chr1NDlUcI8C&amp;pg=PA108&amp;lpg=PA108&amp;dq=coroutine+find_files+cat+grep&amp;source=bl&amp;ots=OCDDzmgZCq&amp;sig=6ldU6qqPblKMl0Qv9li3fBmBsyQ&amp;hl=zh-CN&amp;sa=X&amp;ved=0CCIQ6AEwAGoVChMIxL-D1ciWxwIVzQiOCh26tgyg#v=onepage&amp;q=coroutine%20find_files%20cat%20grep&amp;f=false" target="_blank" rel="external">python参考手册</a>，打印指定目录下，满足格式文件中，有“python”关键字的行</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">    </div><div class="line">    <span class="keyword">import</span> os</div><div class="line">    <span class="keyword">import</span> fnmatch</div><div class="line">    <span class="keyword">import</span> gzip, bz2</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">coroutine</span><span class="params">(func)</span>:</span></div><div class="line">    <span class="string">"""自动调用协程的next()函数"""</span></div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">start</span><span class="params">(*args, **kwargs)</span>:</span></div><div class="line">            g = func(*args, **kwargs)</div><div class="line">            g.next()</div><div class="line">            <span class="keyword">return</span> g</div><div class="line">        <span class="keyword">return</span> start</div><div class="line">    </div><div class="line"><span class="meta">    @coroutine</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_files</span><span class="params">(target)</span>:</span></div><div class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">            topdir, pattern = (<span class="keyword">yield</span>)</div><div class="line">            <span class="keyword">for</span> path, dirname, filelist <span class="keyword">in</span> os.walk(topdir):</div><div class="line">                <span class="keyword">for</span> name <span class="keyword">in</span> filelist:</div><div class="line">                    <span class="keyword">if</span> fnmatch.fnmatch(name, pattern):</div><div class="line">                        target.send(os.path.join(path, name))</div><div class="line">    </div><div class="line"><span class="meta">    @coroutine</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">opener</span><span class="params">(target)</span>:</span></div><div class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">            name = (<span class="keyword">yield</span>)</div><div class="line">            <span class="keyword">if</span> name.endswith(<span class="string">'.gz'</span>): f = gzip.open(name)</div><div class="line">            <span class="keyword">elif</span> name.endswith(<span class="string">'.bz2'</span>): f = bz2.BZ2File(name)</div><div class="line">            <span class="keyword">else</span>: f = open(name)</div><div class="line">            target.send(f)</div><div class="line">    </div><div class="line"><span class="meta">    @coroutine</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cat</span><span class="params">(target)</span>:</span></div><div class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">            f = (<span class="keyword">yield</span>)</div><div class="line">            <span class="keyword">for</span> line <span class="keyword">in</span> f:</div><div class="line">                target.send(line)</div><div class="line">    </div><div class="line"><span class="meta">    @coroutine</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">grep</span><span class="params">(pattern, target)</span>:</span></div><div class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">            line = (<span class="keyword">yield</span>)</div><div class="line">            <span class="keyword">if</span> pattern <span class="keyword">in</span> line:</div><div class="line">                target.send(line)</div><div class="line"><span class="meta">    @coroutine</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printer</span><span class="params">()</span>:</span></div><div class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">            line = (<span class="keyword">yield</span>)</div><div class="line">            sys.stdout.write(line)</div><div class="line">    </div><div class="line">    finder = find_files(opener(cat(grep(<span class="string">'python'</span>, printer))))</div><div class="line"></div><div class="line">finder.send(<span class="string">'www'</span>, <span class="string">'access-log*'</span>)</div><div class="line">finder.send(<span class="string">'otherwww'</span>, <span class="string">'access-log*'</span>)</div></pre></td></tr></table></figure>
</li>
<li><p>并发<br>  关于并发，最好的例子应该是gevent吧，大家有兴趣可以看下源码。基本的原理是，将函数变为协程，每触发I/O阻塞就yield交出控制权，并将事件注册到epoll，当I/O就绪就是用send方法，传入I/O数据，并恢复逻辑。这么描述其实和tornado、nodejs的网络模型很像，但是协程对于程序员更加友好。tornado和nodejs默认还是通过回调函数完成这个事件循环的，这样代码并不直观，但使用协程可以用同步的方式完成回调函数的工作。</p>
</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/07/04/celery有什么难理解的/" itemprop="url">
                  celery有什么难理解的?
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-07-04T14:09:06+08:00" content="2015-07-04">
              2015-07-04
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2015/07/04/celery有什么难理解的/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/07/04/celery有什么难理解的/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>两年前，公司所有的管理后台用的都是django admin，我们遇到一个复杂的需求，需要从django admin调用执行一个大批量处理脚本，并且可以查看执行状态。<br>当时不太了解celery，加上时间紧迫，就没敢冒险。简单说说我们当时是怎么做的，我们把这个脚本做成了command line的形式，django使用python的subprocess调用这个命令，为了满足可以查看状态这个需求，我们单独创建了一个任务表，在启动脚本时先插入数据，完成或者异常都更新这条数据状态，这样在django admin里就能看到执行状态了。<br>这个方法满足了需求，并沿用到现在，但是这里有一个显而易见的硬伤：django必须和这个脚本在同一个服务器上。好吧，毫无可拓展性。<br>其实这个就是一个天然celery使用场景，如果使用celery就可以轻松解决分布拓展问题。</p>
<h2 id="什么是celery？">什么是celery？</h2><p>说了这么多，什么是celery呢？<a href="http://www.celeryproject.org/" target="_blank" rel="external">官网</a>定义：</p>
<blockquote>
<p>Celery is an asynchronous task queue/job queue based on distributed message passing.</p>
</blockquote>
<p>celery是一个基于分布消息传递的异步任务队列。定义很简单，但是这里隐含了一个条件就是celery不是单独存在的，它一定需要建立在一个分布的消息传递机制上，这个消息传递机制就是celery文档里常说的<em>broker</em>。我认为这是第一个难以理解的点。<br>一般情况下，一个工具库或者一个框架都是独立的，有自己的feature或者功能点，可能依赖其他的库，但绝不依赖于其他服务。但是celery是一个特例，如果celery没有broker这个服务，那就完全不能用了。这就是为什么现在网络上大多数celery文章都是和rabbitmq或者redis一起讲的。<br>清楚这点，知道了broker和celery的关系，就不会有rabbitmq不就可以做任务队列吗？为什么和celery结合？这样的疑问。事实上，在<a href="https://www.rabbitmq.com/tutorials/tutorial-two-python.html" target="_blank" rel="external">官网</a>上就有使用rabbit作为任务队列的实现，多种语言都有。rabbitmq是消息代理中间件，具体应用到什么场景，怎么用，用什么语言，都可以自己定义，celery也实现了这个接口而已。</p>
<h2 id="celery结构框架">celery结构框架</h2><p>下面贴一个celery+rabbitmq的结构图，个人认为挺能说明问题：<br><img src="/img/RabbitMQRouting.png" alt="celery rabbitmq结构图"><br>celery隐藏了rabbitmq接口的实现细节，既充当了publisher（client）又充当了consumer (worker)的角色。<br>这是第二个难理解的点，这个困扰可能来源于celery提供的get start文档，如果按照这个文档一步步走，确实能走通流程。但是这个通俗的demo有一个问题，就是他的publisher和consumer都在一台server上，并且client调用具体任务的方式是通过import。这让人很难理解，为什么说celery是分布的呢？但是奇怪的是，官方demo就没有publisher和consumer分布在两台server的例子。</p>
<p><img src="/img/Producer-Broker-Consumer-Arrangement.png" alt="client broker worker关系图"><br>如上图所示，producer、broker、consumer之间的网络拓扑关系可以有这5种情形。</p>
<h2 id="celery到底做了什么？">celery到底做了什么？</h2><p>上文说了，rabbitmq官网就有demo做任务队列的，那要celery有何用呢？还有上边，我提到的那个需求，没用celery，虽然拓展性不好，但是改一下用一个web服务代替不就行了么？这么说没错，但都是重复造轮子。<br>思考一下，如果我们用rabbitmq自己实现任务队列，有一天我们不想用rabbit了怎么办？我们换个思维，如果没有celery，让你自己设计一个异步任务队列你怎么做。首先，要有一个发起任务的client，选定一定保存任务信息的媒介，由一个worker去一直监听这个信息媒介，这个worker最好是多进程的，另外可以兼容尽可能多得信息媒介。好吧，这个不就是celery所做的事儿么，celery兼容多个broker，既是任务发起者又是执行者，另外支持多进程…还有好多通用功能考虑。<br>看一下这个图体会一下celery+rabbitmq的整个工作流程：</p>
<p><img src="/img/Celery_RabitMQ_Diagram.png" alt="Celery_RabitMQ_Diagram"></p>
<h2 id="我是怎么用的?">我是怎么用的?</h2><p>说了这么多，来看看我是怎么用的。</p>
<ol>
<li><p>选择broker和result backend<br>  知道了原理，这个选择要容易些，对于消息中转，没有比rabbitmq更灵活健壮的了，至于对result backend的存储，仁者见仁。rabbitmq安装配置<a href="http://celery.readthedocs.org/en/latest/getting-started/brokers/rabbitmq.html" target="_blank" rel="external">参考</a></p>
</li>
<li><p>提取celery配置文件<br> 把共有配置文件提出来，进行维护，比分别维护producer和consumer的配置统一容易的多。<br> celeryconfig.py</p>
 <figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">BROKER_URL = <span class="string">'amqp://test01:password@192.10.2.156//'</span></div><div class="line">CELERY_RESULT_BACKEND = <span class="string">'amqp://test01:password@192.10.2.156//'</span></div><div class="line">CELERY_ACCEPT_CONTENT = [<span class="string">'json'</span>]</div><div class="line">CELERY_TASK_SERIALIZER = <span class="string">'json'</span></div><div class="line">CELERY_RESULT_SERIALIZER = <span class="string">'json'</span></div></pre></td></tr></table></figure>
</li>
<li><p>consumer（server）端开发</p>
<ul>
<li><p>在项目目录下创建app.py文件</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> Celery</div><div class="line">app = Celery(<span class="string">'tqlib'</span>, include=[<span class="string">'tq.tasks'</span>])</div><div class="line">app.config_from_object(<span class="string">'celeryconfig'</span>)</div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    app.start()</div></pre></td></tr></table></figure>
</li>
<li><p>创建tasks.py</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> tq.app <span class="keyword">import</span> app</div><div class="line"><span class="meta">@app.task</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(no)</span>:</span></div><div class="line">    <span class="keyword">print</span> no</div></pre></td></tr></table></figure>
</li>
<li><p>启动多进程服务<br>  项目目录结构为</p>
<pre><code>tq<span class="comment">----app.py</span>
  |<span class="comment">---tasks.py</span>
  |<span class="comment">---celeryconfig.py</span>
</code></pre><p>  启动指令为：</p>
  <figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">celery</span> <span class="keyword">multi </span>restart ccworker --app<span class="symbol">=tq</span>.app  -l <span class="meta">info</span></div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>producer(client)端开发</p>
 <figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> Celery</div><div class="line">celery = Celery()</div><div class="line">celery.config_from_object(<span class="string">'celeryconfig'</span>)</div><div class="line">celery.send_task(<span class="string">'tq.tasks.test'</span>, (<span class="string">"hello world"</span>,))</div></pre></td></tr></table></figure>
<p>注意，就是celery.send_task()这个方法解决了producer和consumer的网路拓扑传递数据问题。 </p>
</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/06/29/sqlchemy如何分表/" itemprop="url">
                  sqlalchemy如何分表
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-06-29T21:45:39+08:00" content="2015-06-29">
              2015-06-29
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2015/06/29/sqlchemy如何分表/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/06/29/sqlchemy如何分表/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="背景">背景</h2><p>话说sqlalchemy真是一个非常好用的库，python orm基本上是舍我其谁了，文档还非常全面，基本上没有什么硬伤，现在也冲出了1.0版本，未来更加值得期待。<br>我最早用django orm，不过很快就觉得很多功能不够用，我当时用的版本是1.3.1，没有<em>bulk insert</em>也没有<em>锁</em>，没有这两个功能，好多应用就没法用django开发了。之后开始接触sqlalchemy，一直用到现在，总的体会是只有你想不到没有它做不到。</p>
<p>我们项目里有一个需求，就是数据按月分表，比如:2014年6月数据就存在<em>record_201406</em>表中, 其他月数据按此方法类推。这个需求如果是用sqlalchemy来获取数据，我们怎么做呢？</p>
<h2 id="一般方法有什么问题？">一般方法有什么问题？</h2><p>一般情况下，我们很自然想到使用如下方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RecodeDao_201406</span><span class="params">(Base)</span>:</span></div><div class="line">   	__tablename__ = <span class="string">'record_201406'</span></div><div class="line">   	id = Column(INT(<span class="number">11</span>), primary_key=<span class="keyword">True</span>)</div><div class="line">   ...</div></pre></td></tr></table></figure>
<p>或者简化点：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RecodeDao_201406</span><span class="params">(Base)</span>:</span></div><div class="line">   	__table__ = Table(<span class="string">'record_201406'</span>,</div><div class="line">       Base.metadata, autoload=<span class="keyword">True</span>)</div></pre></td></tr></table></figure>
<p>这样实现确实没问题，但回到需求上，既然是按月分表，难不成我要每个月写一个这样的model？每月上次线？当然不行，那我们怎么解决呢？</p>
<h2 id="官网解决方法，有什么问题？">官网解决方法，有什么问题？</h2><p>有经验的同学可能发现，这个不就是水平<em>sharding</em>么？这么说不完全对，看一下sharding的<em>wiki</em>定义：</p>
<blockquote>
<p>A database shard is a horizontal partition of data in a database or search engine. Each individual partition is referred to as a shard or database shard. Each shard is held on a separate database server instance, to spread load.</p>
</blockquote>
<p>我们这个需求只涉及单数据库，就不算<em>sharding</em>了，可以称为<em>partitioning</em>（分区），然而强大的sqlalchemy这两个情况都考虑到了，并且官网都提供了<a href="http://docs.sqlalchemy.org/en/rel_1_0/orm/examples.html#examples-sharding" target="_blank" rel="external">example</a>，我们挑对应场景的partitioning出来看看:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> *</div><div class="line"><span class="keyword">from</span> sqlalchemy.orm <span class="keyword">import</span> *</div><div class="line"><span class="keyword">from</span> sqlalchemy.ext.declarative <span class="keyword">import</span> declarative_base</div><div class="line"></div><div class="line">Base = declarative_base()</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TBase</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="string">"""Base class is a 'mixin'.</span></div><div class="line"></div><div class="line">    Guidelines for declarative mixins is at:</div><div class="line"></div><div class="line">    http://www.sqlalchemy.org/docs/orm/extensions/declarative.html#mixin-classes</div><div class="line"></div><div class="line">    """</div><div class="line">    id = Column(Integer, primary_key=<span class="keyword">True</span>)</div><div class="line">    data = Column(String(<span class="number">50</span>))</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> <span class="string">"%s(data=%r)"</span> % (</div><div class="line">            self.__class__.__name__, self.data</div><div class="line">        )</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">T1Foo</span><span class="params">(TBase, Base)</span>:</span></div><div class="line">    __tablename__ = <span class="string">'t1'</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">T2Foo</span><span class="params">(TBase, Base)</span>:</span></div><div class="line">    __tablename__ = <span class="string">'t2'</span></div><div class="line"></div><div class="line">    timestamp = Column(DateTime, default=func.now())</div><div class="line"></div><div class="line">engine = create_engine(<span class="string">'sqlite://'</span>, echo=<span class="keyword">True</span>)</div><div class="line"></div><div class="line">Base.metadata.create_all(engine)</div><div class="line"></div><div class="line">sess = sessionmaker(engine)()</div><div class="line"></div><div class="line">sess.add_all([T1Foo(data=<span class="string">'t1'</span>), T1Foo(data=<span class="string">'t2'</span>), T2Foo(data=<span class="string">'t3'</span>),</div><div class="line">             T1Foo(data=<span class="string">'t4'</span>)])</div><div class="line"></div><div class="line"><span class="keyword">print</span> sess.query(T1Foo).all()</div><div class="line"><span class="keyword">print</span> sess.query(T2Foo).all()</div></pre></td></tr></table></figure>
<p>使用了继承的方法，抽象的好，但我们之前的问题解决了吗？没有。还是需要预定义好所有表的model类，才能正确使用，迫不得已，我们只能自己想办法了。</p>
<h2 id="函数方法解决">函数方法解决</h2><p>经过一番探索，我得出了如下方法:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">class_registry = &#123;&#125;                                                                                                                                                                    </div><div class="line">DbBase = declarative_base(bind=engine, class_registry=class_registry)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_model</span><span class="params">(modelname, tablename, metadata=DbBase.metadata)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">        args:</div><div class="line">            modelname:新model名，string类型</div><div class="line">            tablename:数据库中表名</div><div class="line">        usage:</div><div class="line">          RecordDao = get_model("RecordDao_201406", "record_201406")</div><div class="line">    """</div><div class="line">    <span class="keyword">if</span> modelname <span class="keyword">not</span> <span class="keyword">in</span> class_registry: </div><div class="line">        model = type(modelname, (DbBase,), dict(</div><div class="line">            __table__ = Table(tablename, metadata, autoload=<span class="keyword">True</span>)</div><div class="line">        ))  </div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        model = class_registry[modelname]</div><div class="line"><span class="keyword">return</span> model</div></pre></td></tr></table></figure>
<p>每次想获取对应月表数据的<em>model</em>，调用<em>get_model</em>方法即可。这个方法一直沿用到现在，虽然有点丑陋，但却是解决了以上问题。直到sqlalchemy 0.9.1版本推出<em>Automap</em></p>
<h2 id="Automap方法">Automap方法</h2><p>sqlalchemy文档完备，具体可点击<a href="http://docs.sqlalchemy.org/en/rel_1_0/orm/extensions/automap.html" target="_blank" rel="external">Automap</a>，它可以自动映射数据库的表，通过数据表名映射model，简单直接，实现起来如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">from</span> sqlalchemy.ext.automap <span class="keyword">import</span> automap_base</div><div class="line"></div><div class="line">AutoBase = automap_base()</div><div class="line"><span class="comment"># reflect the tables</span></div><div class="line">AutoBase.prepare(engine, reflect=<span class="keyword">True</span>)</div><div class="line">tablename = <span class="string">"record_201406"</span></div><div class="line">RecordDao = getattr(AutoBase.classes, tablename)</div></pre></td></tr></table></figure>
<p>这样就可以了，很清晰。但是这个方法有一个缺点，<em>Automap</em>的映射虽然是自动的，但是只有在启动的时候生效，也就是说如果新建一个数据表，而没有告诉<em>Automap</em>，那这个表是找不到的。在实际使用中，可以捕获AttributeError异常，并再次调用<code>AutoBase.prepare(engine, reflect=True)</code> 刷新映射关系。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/06/17/我为什么写博客/" itemprop="url">
                  我为什么写博客?
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-06-17T19:05:26+08:00" content="2015-06-17">
              2015-06-17
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2015/06/17/我为什么写博客/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/06/17/我为什么写博客/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>我以前也有写技术博客的习惯，在csdn上，解决一个问题写一篇，有些工具的使用方式也放上边，比较有规律。</p>
<p>后来换了工作，开始比较忙，就扔下了，等闲下来想写，又觉得不好意思了。那时候眼界宽了，看过很多大牛写的文章，觉得自己写的这么浅显，有点拿不出手，想厚积薄发再写。然后就到了现在，对于写博客来说又有了新认识，所以又准备重新捡起这个习惯。</p>
<p>首先，自己确实有刚需。有的技术问题虽然解决了，但是下次遇到了，细节问题又要重新检索，时间成本高，最好还是找个地方记录。另外，在检索信息的过程中，正是很多博客的内容给了我很多指引，解决了问题，写了博客也可以帮助他人，也算是回馈技术圈的一种方式。写博客还有一种好处就是加深认识，提高表述能力。平时对很多问题确实是有了新的理解，但让我写出来，讲给他人，那还得再深思熟虑一番，这个过程对博主是很有帮助的。这段时间深有体会，才想起来还是要再写博客，至于写得是不是有独到见解，是不是拿得出手，其实也没那么重要，都是自己成长的过程。</p>
<p>本篇作为新博客第一篇，既为了开篇，也为了纪念。至于为什么用了<strong><em>githup page + hexo</em></strong>，确实是为了可定制、免费、省心。另外<a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="external">NexT</a>的主题满足了我的所有需求，如果你喜欢我的博客样式，可以尝试一下。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/avatar.png"
               alt="Leo Shang" />
          <p class="site-author-name" itemprop="name">Leo Shang</p>
          <p class="site-description motion-element" itemprop="description">永远年轻, 永远热泪盈眶</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">8</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Leo Shang</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  

    <script type="text/javascript">
      var disqus_shortname = 'leoshang';
      var disqus_identifier = 'index.html';
      var disqus_title = "";
      var disqus_url = '';

      function run_disqus_script(disqus_script){
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      }

      run_disqus_script('count.js');
      
    </script>
  




  
  
  

  

  

</body>
</html>
